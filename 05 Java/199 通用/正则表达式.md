

# 1. 概述

- 正则表达式主要用于快速校验用户输入的字符串是否符合所需的规则
- 在 Java 中，正则表达式的相关类都在 `java.lang.util.regex.*` 包下，注意在 Java 中，由于 `\` 本身需要转义，因此 `\` 需要写两次
- 可以利用浏览器的控制台快速测试正则表达式匹配问题，例如下述样例：
```js
// 模式匹配 : 返回 true 或 false
/^[a-z]+$/.test('aa0z');
// 另一种匹配(可用于提取) : 成功返回一个对象，失败则返回 null
'does'.match(/^do(es)?$/);
// 子串搜索和匹配（匹配一般要带 ^ 和 $，但子串搜索往往不带）
'doesaaaes'.search(/(es)+$/);
```
- 
- 入门示例 `^[0-9]+abc$` :
    - `^` : 匹配输入字符串的开始位置
    - `$` : 匹配输入字符串的结束位置，也就是 `^` 和 `$` 的内容会用于匹配输入的字符串
    - `[0-9]` : 匹配单个数字
    - `+` : 匹配 1 个多个字符，结合前面的 `[0-9]` 就是至少一个字符
    - `abc` : 匹配串 `abc`，由于后面跟着 `$` 因而就表示以 `abc` 结尾
    - 因此该正则匹配以至少一个数字开头，然后以 abc 结尾的字符串
- 注意正则表达式中不能为了好看自己加空格进行分隔

# 2. 语法

## 2.1 基本内容

**普通字符**

- 包括大小写字母、数字、所有标点符号、部分其他符号

**非打印字符**

- `\cx` : 匹配 x 指明的控制字符，例如 `\cM` 匹配一个 Control-M 或回车符，感觉用处不大
- `\f` : 匹配一个换页符
- `\n` : 匹配一个换行符
- `\r` : 匹配回车符
- `\s` : 匹配任何空白符，包括空格、制表、幻夜等
- `\S` : 匹配任何非空白符，等价于 ` [^\f\n\r\t\v]`
- `\t` : 匹配一个制表符
- `\v` : 匹配一个垂直制表符

**特殊字符**

- 特殊字符，指的是在正则表达式中具有特殊含义的字符，例如 `*` 表示前面的字符出现零次或多次，如果输入串中包含符号 `*` 需要匹配，则在正则中需要写成 `\*` 以匹配输入 (Java 中要 `\\*` 因为 `\\` 才表示一个 `\`)
- 常见特殊字符包括 : `^ $`, `( )`, `[ ]`, `{ }`, `*`, `+`, `?`, `|`, `.`, `\`
    - `^ $` : 分别匹配输入串的开头和结尾
    - `( )` : 标记一个子表达式的开始和结束位置，并可以配合限定符使用
    - `|` : 用于选择，例如 `a|0` 匹配 a 或 0，也可以配合 `( )` 选择两组中的一组
    - `.` : 出 `\n` 外的所有单字符
- 前面的特殊字符包括了限定符，限定符主要用来指定某个字符或某个子表达式需要出现多少次：
    - `*` : 零次或多次，等价于 `{0,}`，例如 `zo*` 能匹配 `z, zo, zoo, zooooo ...`
    - `+` : 一次或多次，等价于 `{1,}`，例如 `zo+` 能匹配 `zo, zoo, zooooo ...` 但不能匹配 `z`
    - `?` : 零次或一次，等价于 `{0, 1}`，例如 `zo?` 能匹配 `z, zo`，`do(es)?` 能匹配 `do, does`
    - `{n}` : 指定出现 n 次
    - `{n,}` : 指定出现 n+ 次
    - `{n,m}` : 指定出现 n-m 次
- 特殊的地方，要匹配输入串中的 \，正则中需要两个 `\\`，而在 Java 中需要四个 `\\\\`

**定位符**

- 定位符用于标记边界
- `^ $` : 前面介绍过
- `\b` : 匹配单词边界，例如 `\bCha`, `ter\b` 都可以匹配句子中的 Chapter 单词（前后要有空格），注意 \b 的位置很重要
- `\B` : 匹配非单词边界，例如 `\Bapt` 可以匹配 Chapter 但不能匹配 aptitude，因为 aptitude 以 apt 开头不符合 \B 的规则

## 2.2 补充

- `*`, `+` 都是贪婪的，它们会尽可能多的匹配文字，只要在它们的后面加上一个 `?`，就可以实现非贪婪或最小匹配
- 例如对于文本 `<H1>Chapter 1 - 介绍正则表达式</H1>`，如果使用 `<.*>`，根据贪心原则，会匹配整句 `<H1>Chapter 1 - 介绍正则表达式</H1>`，而如果使用 `<.*?>`，加了问号会采取最小匹配，因此匹配的内容为 `<H1>`，可以使用 js 字符串的 match 方法或者正则对象的 exec 方法匹配的子串
    - 利用 str 的 match 测试 : `'<H1>Chapter 1 - 介绍正则表达式</H1>'.match(/<.*?>/)`
    - 利用正则的 exec 测试 : `/<.*?>/.exec('<H1>Chapter 1 - 介绍正则表达式</H1>')`
- 选择：用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 `?:` 放在第一个选项前来消除这种副作用
- `?:` 是非捕获元之一，还有两个非捕获元是 `?=` 和 `?!`，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串
- 注意使用 `|` 表示“或”的关系时，要用 `()` 限制范围，否则结果就会出错，但 `()` 会默认作为捕获组，详情参考捕获组和非捕获组部分

## 2.3 捕获组

- 使用 `?:` 表示非捕获组，例如 `^(?:pattern)...`
- [参考链接](https://blog.csdn.net/lxcnn/article/details/4146148)
- 捕获组就是把正则表达式中**子表达式**匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部
- 捕获组有两种形式，一种是普通捕获组，另一种是命名捕获组，通常所说的捕获组指的是普通捕获组，使用小括号对 `( )` 定义，而命名捕获组则使用 `(?<name>Expression)` 定义
- 普通捕获组使用数字进行编号，其中 0 表示整个表达式，然后从前往后依次表示每个子表达式按顺序编号
- 捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用，直接在表达式内部 `\k<number>` 或 `\number` 或 `\k<name>` 或 `\k'name'`

## 2.4 非捕获组 ?:

- [参考链接](https://blog.csdn.net/lxcnn/article/details/4464908)
- 一旦使用了 `( )`，就会默认为是普通捕获组，从而将 `( )` 中匹配的内容捕获到组里，但有些情况下不得不用 `( )` 但并不括号中匹配的内容是什么，后面也不会用到捕获组的内容，这就带来一个副作用，记录这些捕获组就会占用不必要的内存，降低匹配效率
- 设计非捕获组的目的就是为了抵消这种副作用，只进行分组，但不讲子表达式匹配的内容捕获到组里
- 一般在比较复杂且括号较多的表达式，为了效率的情况下，才会考虑使用非捕获组，其它不考虑效率的场景，为了可读性，可以不使用非捕获组

## 2.5 反向引用

- 捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用
- 引用方式 : `\k<number>, \number`, `\k<name>, \k'name'`，其中普通捕获组中的 number 是十进制的数字编号
- 捕获组(Expression)在匹配成功时，会将子表达式匹配到的内容，保存到内存中一个以数字编号的组里，可以简单的认为是对一个局部变量进行了赋值，这时就可以通过反向引用方式，引用这个局部变量的值。一个捕获组(Expression)在匹配成功之前，它的内容可以是不确定的，一旦匹配成功，它的内容就确定了，反向引用的内容也就是确定的了


## 2.6 预查询

- `(?=exp)` : 正向肯定预查询，匹配 exp 前面的位置
- `(?<=exp)` : 反向肯定查询，匹配 exp 后面的位置
- `(?!exp)` : 正向否定查询，匹配后面跟的不是 exp 的位置
- `(?<!exp)` : 反向否定查询，匹配前面不是 exp 的位置
- 样例：
```js
// 前瞻：
exp1(?=exp2) 查找 exp2 前面的 exp1
// 后顾：
(?<=exp2)exp1 查找 exp2 后面的 exp1
// 负前瞻：
exp1(?!exp2) 查找后面不是 exp2 的 exp1
// 负后顾：
(?<!exp2)exp1 查找前面不是 exp2 的 exp1
```


# 9. 常用正则

- 至少 8 个字符，至少一个字母和一个数字，只允许 @#$()+-*/%^&,.?! 这几个特殊字符，`^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@#$()+\-*/%^&,.?!]{8,}$`
    - `(?=.*[A-Za-z])` : 前向预查询，声明在 ^ 之后必须包含一个大写字母或小写字母
    - `(?=.*\d)` : 前向预查询，在 ^ 之后必须包含一个数字
    - `[A-Za-z\d@#$()+\-*/%^&,.?!]{8,}` : 仅支持指定的字符，长度至少为 8
- 邮箱 : `^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$`
