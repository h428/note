---
title: MySQL 基本原理
categories:
  - MySQL
date: 2020-09-17 11:14:14
---



# 存储引擎

- 常见的存储引擎有：MyISAM （发音类似 My I SAM）、InnoDB、MEMORY、Archive

**MyISAM**

- MyISAM 特性为
    - 使用表级索，并发性差，不支持事务
    - 主机宕机后，MyISAM 表已损坏，灾难性恢复不佳
    - 可以配合锁，实现操作系统下的复制、备份、迁移
    - 只缓存索引，数据的缓存是利用操作系统缓冲区来实现的，可能引发过多的系统调用且效率不佳
    - 数据紧凑存储（类似线性表的方式进行组织），因此可以获得更小的索引和更快的全表扫描性能
- MyISAM 索引原理：
    - MyISAM 数据可以看成按顺序表的形式组织，每行记录有自己的地址
    - MyISAM 使用 B+ 树作为索引结构，当创建索引列时，会使用该列的数据构造一个 B+ 树，而该 B+ 树的叶节点的 data 域存放的就是对应数据记录的地址
    - 根据上述索引原理可以看出，MyISAM 数据的组织顺序与主键无关，主键索引除了要求 key 唯一外，与其他索引无区别，因此 MyISAM 的主键索引相对于 InnoDB 来说是非聚簇索引

**InnoDB**

- MySQL 5.5 后默认使用 InnoDB 存储引擎
- 其优点为：灾难恢复性好，支持事务，使用行级锁，支持外键关联，支持热备份
- 对于 InnoDB 的数据表，其数据的物理组织形式是簇表，即主键索引为聚簇索引，数据会按主键的顺序进行物理分布
- InnoDB 还实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取
- InnoDB 索引原理：
    - 虽然 InnoDB 也使用 B+ 树作为索引结构，但具体实现方式却与 MyISAM 截然不同
    - 第一个重大区别就是 InnoDB 的数据文件本身就是索引文件，即在 InnoDB 中，数据文件本身就是根据主键按照 B+ 树组织的一个索引结构，这棵 B+ 树的 data 域保存了完整的数据记录
    - 区别于 MyISAM，InnoDB 的主键索引为聚簇索引，数据按照主键进行组织
    - 因此，根据 InnoDB 的这种数组组织原理，InnoDB 要求表必须有主键（而 MyISAM 可以没有主键），否则无法根据主键组织数据的存储
    - 如果没有显式指定主键，MySQL 会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，MySQL 会自动为 InnoDB 生成一个隐含字段作为主键，这个字段长度为诶 6 Byte，类型为长整型
    - 第二个与 MyISAM 索引的区别就是：InnoDB 的辅助索引的 data 域存储相应记录的主键的值而不是数据的地址，即 InnoDB 的所有辅助索引都要引用主键作为 data 域
    - 显然，聚簇索引的这种实现方式使得按主键搜索十分高效，但是根据辅助索引时需要检索索引两边：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录
    - 根据上述 InnoDB 的聚簇索引原理，就很容易明白为什么不建议使用过长的字段作为主键，因为所有的辅助索引都引用该主索引，过长的主索引将导致辅助索引变的过大
    - 再者，对于 InnoDB，使用非单调的字段作为主键也会产生问题，其会导致在插入新记录后，数据文件为了维持 B+ 树的平衡性而频繁地调整或旋转，十分低效，因此对于 InnoDB 存储引擎，主键应选择为自增长或者按照插入顺序增长，否则会影响插入的性能（过多的 B+ 树平衡旋转调整）


**Memory**

- 提供内存表，也不支持事务和外键
- 查询生成的临时表就是采用 Memory 引擎
- 由于数据存储在内存中，显著提高数据的访问速度，可用于缓存会频繁访问的、可以重构的数据，计算结果、统计值、中间结果等
- 优点为：
    - MEMORY表 的每个表可以有多达 32 个索引，每个索引 16 列，以及 500 字节的最大键长度
    - 可以在一个 MEMORY 表中有非唯一键值
    - MEMORY 支持 HASH 索引
- 缺点为：
    - 使用表级锁，虽然内存访问快，但如果频繁地读写，表级锁会成为瓶颈
    - 只支持固定大小的行，varchar 类型字段会因为存储为定长的 char 类型，浪费空间
    - 不支持 text, blob 字段，当查询需要到临时表时，如果表中有 TEXT, BLOB 字段，那么会转换为基于磁盘的 MyISAM 表，严重降低性能
    - 由于内存资源成本昂贵，一般不建议设置过大的内存表，如果内存表满了，可以通过清楚数据或者掉秤内存表参数来避免报错
    - 服务器重启后数据会丢失，对于 Memory 表的复制和维护需要特别小心


**InnoDB 与 MyISAM 的大致区别以及如何选择**

- 从 MySQL5.5.5 以后，InnoDB 是默认引擎
- InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要；事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM 就不可以了
- MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用
- InnoDB 支持外键，MyISAM 不支持
- 它们的索引原理不同
- InnoDB 支持 MVCC, 而 MyISAM 不支持
- MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引
- InnoDB 中不保存表的行数，如 `select count(*) from table` 时，InnoDB 需要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可；注意的是，当 count(*) 语句包含 where 条件时 MyISAM 也需要扫描整个表
- 对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中可以和其他字段一起建立联合索引
- 清空整个表时，InnoDB 是一行一行的删除，效率非常慢；MyISAM 则会重建表
- InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'），而 MyISAM 为表锁
- 有人说 MYISAM 只能用于小型应用，其实这只是一种偏见，如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，读写分离，而不是单纯地依赖存储引擎
- 现在一般都是选用 InnoDB 了，主要是 MyISAM 的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM 对于读写密集型应用一般是不会去选用的

# 事务特性

- 事务：程序中的一系列相关操作
- 事务的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），简称为 "ACID" 特性
- Atomiticy : 事务是数据库操作的逻辑工作单位，不可分割，所有操作要么全部成功，要么全部失败
- Consistency ：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
    - 因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态
    - 如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态
- Isolation : 一个事务的执行不能干扰其他事务，即一个事务的内部操作对其他操作是隔离的，并发执行之间不能互相干扰，事务有 4 种隔离级别
- Durability : 指的是事务一旦成功提交，则它对数据的改变就应该是永久性的，不能回滚，接下来的其它操作或者故障不应该对其执行结果有任何影响


# 隔离级别

- 当多个线程同时操纵数据库时，数据库系统要能进行隔离操作，以保证各个线程获取的数据的准确性
- 脏读：一个事务堵到了另一个事务未提交的数据
- 不可重复读：对于数据库的某行数据，一个事务内的多次查询返回了不同的记录值（因为第二次查询该行时已经被另一个事务修改了）
- 幻读：幻读的重点在于 insert，T1 批量查询范围记录或更新多条记录，然后等待提交，此时 T2 插入一条满足 T1 条件的新数据并成功提交，导致事务 T1 再次使用同样的选择条件读取的时候，得到了比第一次读取更多的数据集，就好像产生了幻觉一样
- 不可重复读和幻读的区别：
    - 不可重复读重点在于 update 和 delete，而幻读的重点在于 insert
    - 如果使用锁机制来实现这两种隔离级别，在可重复读中，该 sql 第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了
    - 但这种方法却无法锁住 insert 的数据，所以当事务 A 先前读取了数据，或者修改了全部数据，事务 B 还是可以 insert 数据提交，这时事务 A 就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免，需要Serializable隔离级别，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力
    - 所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题
    - 上文说的，是使用悲观锁机制来处理这两种问题，但是 MySQL、ORACLE、PostgreSQL 等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题
- 隔离级别详细大致如下：

|隔离级别|英文|作用|
|:---:|:---:|:---:|
|读未提交|read uncommited|会脏读，也不可重复读，会幻读|
|读已提交|read commited|避免脏读，但不可重复读，会幻读|
|可重复读|repeatable read|避免脏读，且可重复读，但会幻读|
|序列化|serializable|可避免脏读、不可重复读、幻读|

**InnoDB 通过什么方式解决幻读的问题**

- [MySQL 的 RR 如何防止幻读](https://github.com/Yhzhtk/note/issues/42)
- 根据标准，RR 隔离级别并不能避免幻读，但实际上，InnoDB 的 RR 级别通过 MVCC 和 next-key lock 解决了幻读的问题，
- 要说明白这个问题，首先要明白，MySQL 中的读分为快照读和当前读
- 快照读：即普通的 select，例如 `select * from table`，InnoDB 在执行当前读之前会备份快照，之后其他事务的快照读都会基于该快照继续操作，这样其他后开的事务就看不到当前事务中的内容（其实每个 select 都有自己的快照）
- 当前读：特殊的读操作，插入/更新/删除，都属于当前读，处理的都是当前读数据，需要加锁
    - `select * from table where ? lock in share mode`
    - `select * from table where ? for update`
    - `insert, update, delete`
- 假设有两个事务 T1 和 T2，T1 执行批量查询（快照读）或者批量更新（当前读），T2 执行插入满足 T1 查询条件的数据，我们以此为例说明 MySQL 下幻读的解决
- 对于快照读，通过 MVCC 与事务版本号在解决不可重复读的同时解决了幻读，详细参考 [MVCC 原理](#4-mvcc-原理)
    - 对于 RR 下的快照读，由于引入 MVCC 机制，在 T1 开启事务后，其能查询的到的数据保持为当前 readview 所允许读到的最新数据，因此天然地可避免幻读
    - 即使此时 T2 开事务插入数据，由于其版本号大于 T1 版本号，因此插入的数据会被 T1 的 readview 过滤并不会被 T1 读到，从而避免了幻读
    - 注意，MVCC 快照读本身就包括两部分可见：1、事务开始前已提交的可见 2、自己本事务的修改可见，因此若 T2 先开事务并插入数据但未提交，插入的数据对于 T1 仍然不可见，RR 有个一致性快照（T2 先开事务插入数据但未提交属于 MVCC 解决脏读问题）
- 对于当前读（写也算当前读），InnoDB 通过 Next-Key 锁来解决幻读，Next-Key 锁是行锁和GAP（间隙锁）的合并，详细参考 [Next-Key 锁](#5-next-key-锁)


# MVCC 原理

- [参考地址](https://www.cnblogs.com/rongdi/p/13378892.html)
- MVCC 的作用：
    - 用于事务的回滚 -> undo log
    - 事务的在尽量不加锁的情况下进行并发控制
    - 解决了快照读下的幻读问题

**MVCC 实现原理**

- InnoDB 为数据表增加两个隐藏列 DATA_TRX_ID 和 DATA_ROLL_PTR，用于实现 MVCC，其中 DATA_TRX_ID 表示事务 id，DATA_ROLL_PTR 指向 undo log 指针，注意并不是所谓的 delete_trx_id
![隐藏列](https://raw.githubusercontent.com/h428/img/master/note/00000137.jpg)
- 当事务 A 对 x 进行更新后，该行即产生了一个新版本和旧版本，假设插入之前该行的事务 ID 为 100，当前事务 A 的事务 ID 为 200，操作过程如下：
    - 对 ID = 1 加排他锁
    - 把原有数据拷贝到 undo log 中
    - 修改行值并更新 DATA_TRX_ID 为当前事务 ID，并将 DATA_ROLL_PTR 指向 undo log 中的记录
    - 注意 undo log 是一个链表，可能 B 事务在 A 之后开并先执行了 update，这时 A update 会锁住，B commit 后 A 可以继续，若是可重复读，但能访问的数据不是前一个节点而应该是前前节点，因为 A 先于 B 开启，不能读到 B update 之后的数据，所以必须以链表形式保存下所有的更新记录
- 基于上述操作，如何判断读取的时候应该使用哪个版本？MySQL 引入了当前状态的 ReadView 的概念，主要包含如下属性：
    - mIds : 代表生成 ReadView 时，当前活跃的事务 id 但不包括当前事务 id，活跃即开启了还没提交
    - min_trx_id : mIds 中的最小值，即最早开的还活跃的事务
    - max_trx_id : 生成 ReadView 时，最大的事务 id，注意不要理解成 mIds 中最大的 ID，对于 RR 快照读，由于需要可重复读，一般只生成一次 ReadView，此时 max_trx_id 为本事务的 id；但对于 RC，由于需要读取到其他后开事务 commit 后的数据，因此需要多次生成 ReadView，因此此时 max_trx_id 可能大于当前事务 id
    - creator_trx_id : 当前事务 id
- ReadView 引入上述 4 个属性后，如何判断读取哪个版本的数据呢？
    - 如果被访问的数据的 data_trx_id 小于 min_trx_id，则表示该版本的数据在生成 ReadView 之前已经 commit，可以访问
    - 如果被访问数据的 data_trx_id 大于 max_trx_id，表示该版本的数据是在 ReadView 生成之后新生成的事务写入的，当前 ReadView 不能访问
    - 如果被访问数据的 data_trx_id 处于区间 `[min_trx_id, max_trx_id]`，则判断该数据的 data_trx_id 是否处于 mIds 列表，是则表示生成 ReadView 时该数据为还活跃着的事务修改的，不能访问（这也是为什么不把自己的 id 放入 mIds 中，否则导致自己修改的无法访问）；如果不在，则说明生成 ReadView 时该版本的事务已经提交，可以访问（读已提交则需要生成多次 ReadView 以保证读到更新的数据）

**MVCC 在 RC 和 RR 隔离级别下有啥区别**

- 先说 RC 级别，两个版本不一致，说明可能事务 A 两次使用的 ReadView 里的内容肯定是有不一样，结合 B 事务中间有提交，而提交事务很明显会影响到 mIds 当前活跃事务列表，因为事务提交之后就不是活跃事务了不可能再出现在 mIds 列表中了，这一点很好理解
- 再来看 RR 隔离级别事务 A，如果要两次读取的 x 值一致，除非两次用来判定的 ReadView 没有啥变化，这不由得让我们想起了缓存的用法，是不是可以在 A 事务开启的时候生成一个 ReadView，然后在整个 A 事务期间都用这一份 ReadView 就行了呢，就像用缓存一样
- 而 RC 级别每次查询都生成一个最新的 ReadView，是不是就可以产生区别了，这算是一个比较常规并且巧妙的设计了

**InnoDB 解决幻读**

- 在 RR 下，对于快照读，只在开启事务时生成一次 ReadView，从而天然避免了幻读
- 而对于当前读，InnoDB 则会对相关的数据自动加 next-key 锁，以避免其他事务修改该数据，只有当前事务提交后，其他数据才能修改相关数据，因此当前事务的前后读取到的相关数据不会变化，从而避免了幻读


# 5. Next-Key 锁

- Next-Key 锁是行锁和 GAP（间隙锁）的合并，行锁上文已经介绍了，接下来说下 GAP 间隙锁
- 行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况，但如何避免别的事务插入数据就成了问题
- RR 级别中，事务 T1 在批量 update 后加锁，事务 T2 将无法插入新数据，这样事务 T1 在 update 前后读的数据保持一致，避免了幻读，这个锁，就是 Gap 锁
- 对于 Gap 锁是这么实现的：
    - 若 T1 中的 where 条件是个索引，由于 InnoDB 会维护关于该索引的 B+ 树，data 域为主键，当 T1 执行当前读时，则在条件所在的 B+ 树区间加锁，此时将 T2 事务无法插入索引列值若在该区间的数据（区间外的可以插入），直到 T1 提交后 T2 才能插入，这样 T1 的多次当前读都是一致的，从而避免了幻读
    - 若 T1 中的 where 条件不是索引字段，则会给全表加 gap 锁，此时 T2 将无法插入任何数据，直到 T1 提交事务后 T2 才可以插入，这样 T1 的多次当前读都是一致的，从而避免了幻读
- 总结：行锁防止别的事务修改或删除，GAP 锁防止别的事务新增，行锁和 GAP 锁结合形成的的 Next-Key 锁共同解决了 RR 级别在写数据时的幻读问题
- 间隙锁测试，测试数据为 100 行，如果只是行锁，下面两句 sql 在不同的事务中理论上不会导致阻塞，但实际上经测试会导致阻塞，若将 id 改为 4 或更大又不阻塞，可以尝试其他 id 区间、对应附近 id、对应较远 id 查看阻塞情况测试间隙锁
```sql
update user set name = 'ttt' where id < 3;
update user set name = 'zzz' where id = 3;
```

# 6. 范式

- 1 NF : 列不可分割，标准的二维表天然满足，在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库
- 2 NF : 非主属性完全依赖于主属性，而不能只依赖关键字的一部分，比如如果以 (id, age) 为主键，其他列就会部分依赖主键，因为其他列完全依赖 id
- 3 NF : 属性不依赖于非主属性，即不能有传递依赖，比如 stu_id, class_id, class_name，stu_id 为主键，class_name 依赖于 class_id，对主键出现了传递依赖 stu_id -> class_id -> class_name
