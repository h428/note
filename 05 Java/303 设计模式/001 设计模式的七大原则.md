

# 0. 概述

- 网上基本都说设计模式的六大原则，但对六大原则的说法具体不一致，总结了不同说法，其实总共有七种不同的原则
- 对于网上的说法，区别主要在于前五种原则一样，最后一种说法不同，分别是单一职责原则和合成复用原则
- 因此，综合起来，有七大原则：
    - 单一职责原则（Single Responsibility Principle, SRP）
    - 里氏代换原则（Liskov Substitution Principle, LSP）
    - 依赖倒转原则（Dependence Inversion Principle, DIP）
    - 接口隔离原则（Interface Segregation Principle, ISP）
    - 迪米特法则（Law of Demeter, LoD），又叫最少知识原则（Least Knowledge Principle, LKP）
    - 开闭原则（Open Close Principle, OCP）
    - 合成复用原则（Composite Reuse Principle, CRP）
- 设计模式七大原则相当于软件开发的内功心法，而 23 种设计模式则是根据这些原则，总结出来的非常经典且常用的设计，和设计原则相比，可以理解为外功技巧
- 推荐：[设计模式之禅](https://www.kancloud.cn/sstd521/design/193491)

# 1. 单一职责原则

- Single Responsibility Principle, SRP
- 定义：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因
- **单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则**
- 这个原则最关键的地方就是：对职责的定义，什么是类的职责，以及怎么划分类的职责
- 一个类承担的职责越多，被复用的可能性就越小
- 一般来说，实现类很难完完全全遵循单一职责原则，且生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责
也会人为地增加系统的复杂性
- 接口一定要做到单一职责，实类的设计尽量做到只有一个原因引起变化（往往很难做到），不得已的情况下可以适当违反单一职责原则，实现多个接口
- 此外，除了类，单一职责原则同时也适用于方法：一个方法尽可能做一件事
情，即尽量使用细粒度的方法，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这违反了单一职责原则，会造成维护的困难

# 2. 里氏替换原则

- Liskov Substitution Principle, LSP
- 定义 1 ：如果对每一个类型为 S 的对象 o1，都有类型为 T 的对
象 o2，使得以 T 定义的所有程序P在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型
- 定义：所有引用基类的地方必须能透明地使用其子类的对象
- 问题由来：我们在继承父类，对父类功能进行扩展时，可能会覆盖父类原有功能，然后我们用子类代替父类时，可能导致其他地方原有的调用代码产生问题（因为根据多态，原本指向父类的方法现在会调用子类的方法，这可能产生问题）
- 问题2：除了覆盖，重载时采用更加严格的参数类型也会导致类似覆盖的情况，严格指的是相比于父类的方法参数类型，比如是 Map，子类重载的方法参数是父类参数的子类比如 HashMap，由于 HashMap 是 Map 的子类，这种情况下即使没有覆盖，对子类进行调用时也可能使得调用时调用到子类的方法，从而使得子类无法替换父类
- 我们看下面例子：SubBase 是 Base 子类，扩展 Base 的功能，重载了更加严格的参数类型，这将使得子类无法透明地替代父类，产生类似覆盖的问题，违背了里氏替换原则
```java
class Father {
    public void doOperation(Map map) {
        System.out.println("Base");
    }
}

class Son extends Father {
    /**
     * 重载，且方法参数比父类的更加严格（TreeMap 是 Map 的子类），违背了里氏替换原则
     * @param map 比父类更加严格的参数类型
     */
    public void doOperation(TreeMap map) {
        System.out.println("SubBase");
    }
}

public class Client {
    public static void main(String[] args) {
        TreeMap map = new TreeMap();
        Father father = new Son();
        father.doOperation(map);  // 本行调用的是父类的方法

        // 由于子类 Son 重载违背了里氏替换原则，使得子类无法替代父类
        // 在 Son 没有添加重载时，下面的代码本来会调用 Father.doOperation 方法
        // 但由于违背了里氏替换原则进行重载，原有的调用逻辑直接变为调用 Son.doOperation，从而可能产生 bug
        Son son = new Son();
        son.doOperation(map); // 相同的调用代码，我明明没有覆盖，却仿佛做了覆盖一样，调用的是子类的方法
    }
}
```
- 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
    - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
    - 子类中可以增加自己特有的方法（一般用在产品迭代时扩展功能）
    - 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。（不建议重载）
    - 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。（不建议重载）
- 如果子类不能完整地实现父类的抽象方法，或者需要覆盖父类已经正确实现的方法，则违背里氏替换原则，此时建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承
- 但产品迭代时，若需要扩展功能，可以增加新的接口，继承原有实现类的同时实现新接口，以扩展功能，以达到开闭原则的目的，但注意继承时一定要遵循里氏替换原则
- 注意继承时避免为子类新增接口中没有的方法，这违背了依赖倒置原则（若你遵循了依赖倒置，即使新增了你也调用不到新增的方法，因为接口中没有声明对应方法）

# 3. 依赖倒置原则

- Dependence Inversion Principle, DIP
- 依赖倒置原则定义包含下述三层含义：
    - 高层模块不应该依赖低层模块，两者都应该依赖其抽象
    - 抽象不应该依赖细节
    - 细节应该依赖抽象
- 该原则是开闭原则的基础，说白了就是面向接口编程（OOD, Object-Oriented Design）
- 声明依赖的方式有三种：构造器、set、接口声明（实现接口）
- 该原则有以下最佳实践：
    - 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
    - 变量的表面类型尽量是接口或者是抽象类（注意不是绝对的，比如工具类就不需要，此外如果要使用类的 clone 方法，就必须使用实现类，这是 JDK 提供的一个规范）
    - 任何类都不应该从具体类派生（维护项目时需要扩展功能则可以违背该原则，此时要结合里氏替换原则使用）
    - 尽量不要覆写基类的方法（里氏替换原则）
    - 结合里氏替换原则使用
- 依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要途径，依赖倒置原则没有实现，就别想实现对扩展开放，对修改关闭

# 4. 接口隔离原则

- 接口隔离原则定义如下；
    - 客户端不应该依赖它不需要的接口
    - 类间的依赖关系应该建立在最小的接口上（即提供的接口不应该包含不需要的方法）
- 上述定义可以概括为：建立单一接口，不要建立臃肿庞大的接口，接口尽量细化，同时接口中的方法尽量少
- 注意，**接口隔离原则与单一职责的审视角度是不相同的**，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少
- 例如一个接口的职责可能包含 10 个方法，这 10 个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”
- 即指提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问
- 拿很常见的学生管理系统来说，对于 IStudentService，按业务层面来说，可能有登录、查询信息、新增、删除、更新学生信息等业务，因此根据单一职责原则，可以将这些方法都放在一个接口中；但是，实际上，学生模块自己只需要查询信息、登录、更新个人信息方法，而管理员模块才具有新增学生、删除学生等方法，因此根据接口隔离原则，需要将方法分别拆分到各自的接口中，供各自的上层模块使用，这就是尽量细粒度地划分接口而不是提供一个臃肿的接口
- 接口隔离原则大致包含如下含义：
    - 接口要尽量小
    - 接口要高内聚（即尽量少公布 public 方法）
    - 定制服务（即给不同模块的接口要拆分出来，以给不同模块提供不同的服务）
    - 接口设计是有限度的（不能无限地细粒度划分，要根据经验权衡）
- 根据接口隔离原则，可以有以下最佳实践：
    - 一个接口只服务于一个子模块或业务逻辑
    - 通过业务逻辑压缩接口中的 public 方法，尽量保持接口的精简，避免提供不必要的 public 方法
    - 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用**适配器模式**进行转化处理
    - 了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中

# 5. 迪米特法则

- 迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）
- 一个对象应该对其他对象有最少的了解
- 通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多 public 方法，我就调用这么多，其他的我一概不关心
- 一个类公开的 public 属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大
- 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中
- 迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高
- 在实际应用中，如果一个类跳转两次以上才能访问到另一个类，就需要想办法进行重构了
- 跳转次数越多，系统越复杂，维护就越困难，所以只要跳转不超过两次都是可以忍受的
- 迪米特法则要求类间解耦，但解耦是有限度的，在实际的项目中，需要适度地考虑这个原则，别为了套用原则而做项目
- 依据迪米特法则提出的很经典的设计模式：外观模式


# 6. 开闭原则


- 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
- 开闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化
- 开闭原则是最基础的一个原则，其他原则都是开闭原则的具体形态，它们是指导设计的工具和方法，而开闭原则才是其精神领袖
- 如何使用开闭原则
    - 抽象约束（精简接口、抽象尽量保持稳定不得修改）
    - 元数据（metadata）控制模块行为（IOC）
    - 制定项目章程（项目约定和注解扫描等）
    - 封装变化（将变化抽象到接口；23 种设计模式）
- 最佳实践：
    - 遵循其他原则，而开闭原则又是重中之重，是最基础的原则，是其他原则的精神领袖，其他原则都是为了达到开闭原则这一目的
    - 开闭原则也只是一个原则，实现拥抱变化的方法非常多，并不局限于这6大设计原则，但是遵循这6大设计原则基本上可以应对大多数变化
    - 项目规章非常重要
    - 预知变化，做一个好的架构
- 开闭原则是一个终极目标，任何人包括大师级人物都无法百分之百做到，但朝这个方向努力，可以非常显著地改善一个系统的架构，真正做到“拥抱变化”

# 7. 合成复用原则

- 定义：尽量使用对象组合，而不是继承来达到复用的目的
- 复用时要尽量使用组合/聚合关系（关联关系），少用继承，因为继承具有极强的耦合
- UML 类图中的关联、组合、聚合区别：
    - 关联：两个对象之间存在关系，代码上体现为成员变量
    - 聚合：较强的关联关系，是整体和个体的关系，如人群与人
    - 组合：比聚合还要强的关联关系，也是整体和个体的关系，但组合关系中的个体不能脱离整体存在，比如人和四肢
- 在 Java 中，关联、组合、聚合都是通过成员变量体现的，它们在代码上体现一致，但在逻辑上还是具有一定差别的
- 一般，组合级别的关联关系会使用构造器进行注入（但不是一定，比如部门必须依赖于公司，这是组合关系，但是公司不一定必须要有部门，比如创业公司，但为了逻辑完整，我们可以为其创建一个部门）
- 此外还有一个依赖关系，其是通过方法参数和方法内部的调用来产生的依赖，耦合性比关联关系弱
