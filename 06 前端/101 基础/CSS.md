
# CSS 概述

## 简介

- CSS 即层叠样式表，其定义如何显示 HTML 元素，目前最新版本为 CSS 3 
- 通过 CSS 能够做到网页表现与内容分离，相对于 HTML 的表现， CSS 能够对网页中对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，是目前基于文本展示最优秀的表现设计语言


## 引入 CSS 的方式

- CSS 包括内联样式表/行内样式表、内部样式表、外部样式表，它们的引入方式分别如下：
- 行内样式表：使用 html 元素的 style 属性引入（style 属性是 HTML 5 中的全局属性，用于设置元素的行内样式）
- 内部样式表：一般位于 head 标签内部，使用 `<style type="text/css">...</style>` 定义内部样式表
- 外部样式表：在外部的 .css 文件定义，并使用 `<link rel="stylesheet" type="text/css" href="main.css"></link>` 引入外部样式表
- 层叠是指多个样式可以层叠为一，优先级高的会覆盖优先级低的，所有的样式会根据下面的规则进行层叠，最终确定样式：
    - 浏览器缺省设置（最低）
    - 外部样式表
    - 内部样式表（位于 head 标签内部）
    - 内联样式（在 HTML 元素内部，优先级最高）
- 全局属性指的是可用于任何 HTML 5 元素的属性，例如 style 属性就是全局属性，即所有 HTML 元素都有 style 属性
- 行内样式优先级最高，但不建议使用，因为这使得文本与样式混合
- 同等级别的选择器下，内部样式表的优先级大于外部样式表，但若外部样式表中的选择器优先级较高，则内部样式表的设置可能不起作用，详细参考选择器的优先级
- 外部样式表可以极大提高工作效率



# 选择器

- CSS 选择器：要对 HTML 元素设置样式，就需要把不同的标签选出来，而选择器就是将这些元素选出来
- 语法主要有两部分构成：选择器以及应用在选择器上的样式声明，如 `selector {declaration1; declaration2; ... declarationN}`，多个样式声明声明使用分号分隔
- 选择器即通过一定的规则选择出你想要的 HTML 元素，然后把后面的样式声明应用在你选择出来的元素上
- 每条样式声明包括样式属性和值组成，形如 `selector {property1: value1; property2: value2;}`
- 例如 `h1 {color:red; font-size:14px;}` 中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值
- 可以对选择器进行分组，将同一种样式应用在多个选择器上，例如下述代码
```css
h1,h2,h3,h4,h5,h6 {
    color: green;
}
```
- 子元素会继承父元素的属性设置，如果想要解决继承问题，可以单独为子元素设计样式
- 选择器主要可以划分为五个大类：基础选择器、组合选择器、伪类选择器、伪元素选择器和属性选择器

## 简单选择器

- 简单选择器包括：元素选择器、id 选择器、类选择器和通用选择器

### 元素选择器

- 元素选择器：根据元素名称选取对应的元素，例如 div, h1, p 等，`p { }`

### id 选择器

- id 选择器：根据 HTML 元素的 id 来选取出元素，例如 `#root { }`，注意 id 是唯一的
- 可以为 HTML 元素 id 属性来为该元素设置一个唯一 id，注意 id 必须是唯一的，不能和其他元素的 id 重复
- id 选择器使用前缀 `#`，例如 `#red {...}` 选出 id 为 red 的元素

### 类选择器

- 类选择器：根据 HTML 元素的类来选取出属于该类的元素，例如 `.red { }`
- 使用 HTML 元素的 class 属性为该元素设置类，一个元素可以设置多个 class，一个 class 也可以被赋值给多个元素
- 类选择器使用前缀 `.`，例如 `.center {...}` 选择出 class=center 的元素
- class 可以不唯一，不同的多个元素可以定义同一个 class，因此类选择器一般都会选择出多个元素，这点和 id 选择器不同
- 类选择器的语法可以和元素元素选择器的语法结合，可看做是一种扩充的类选择器，可以选取出元素为目标元素且同时 class 值为指定类名的元素：例如 `td.fancy {....}` 将选择所有 class=fancy 的 td 元素，其他 class=fancy 的元素不会被选取

### 通用选择器

- 通用选择器：使用通用选择器 `*` 选择出页面上的所有 HTML 元素，例如 `* {}`

### 选择器的分组用法

- 选择器的分组语法：对于多个选择器，可能要设置同一个样式，此时可以将多个选择器使用 `,` 连接起来，构成同一个分组统一设置样式，例如下述代码将统一对 h1, h2, h3 设置样式，而不需要重复写三次：
```css
h1, h2, h3 {
    text-align: center;
    color: red;
}
```
- 对于分组用法，本质上就是对多个不同的选择器设置同一样式，因此在编写代码时，习惯每个选择器占一行，以便于理解
```css
h1,
h2,
h3 {
    text-align: center;
    color: red;
}
```

## 组合选择器

- 组合选择器：基础选择器根据各个元素之间的关系（父子、后代、兄弟）互相组合产生的选择器，其以基础选择器为基础，也叫派生选择器
- 组合选择器包括：后代选择器（空格）、子元素选择器（`>`）、相邻兄弟选择器（`+`）和后续兄弟选择器（`~`）


### 后代选择器

- 选择某元素内部（或者叫后代）的所有元素，如 `div p {...}` 选择 div 内部的所有 p 元素

### 子元素选择器

- 相对于后代选择器，该选择器只选择子元素，如 `div > p {...}` 选择选择父元素为 div 元素的所有 p 元素

### 相邻兄弟选择器

- 只会选择相邻的元素，`div + p {...}` 选择和 div 相邻的 p 元素
- 还要注意的是， 上述代码，如果 div 后面的相邻元素不是 p 的话，则该选择器无法作用

### 后续兄弟选择器

- 后续兄弟选择器，该选择器会选择前缀元素之后的所有的兄弟选择器
- 例如，`p ~ ul {...}` 选择 p 元素之后的所有兄弟 ul 元素 （p 和这些 ul 拥有同一个父元素），但 p 之前若有 ul 则不会被选取



## 其他选择器


### 属性选择器

- 属性选择器包括选择含有指定属性的元素、属性值为指定值得元素等，可查看下述例子：
- 含有指定属性：`a[target]` 选择出所有含有 target 属性的 a 元素
- 属性值为指定值：`a[target=_blank]` 选择出所有 target=_blank 的 a 元素
- 属性值开头为指定的单词：`[class|=top]` 选择出 class 属性值以 top 开头的元素，注意选择出来的元素，它们的属性值必须是该单词，或者后面跟着连字符，比如 `[lang|=en]` 可以选择出 `lang="en-us"` 与 `lang="en"` 的元素
- 属性值开头为指定的值：`[class^=test]` 选择所有 class 属性以 test 开头的元素
- 属性值结尾为指定的值：`[class$=test]` 选择所有 class 属性以 test 结尾的元素
- 属性值包含指定值：`div[class*=test]` 选择所有 class 属性包含 test 的 div 元素

### 伪类选择器

- 伪类选择器一般用于描述元素不同状态下的样式（例如当鼠标经过就是一种状态），使用符号 `:`，配合冒号前面的选择器选择元素，使用冒号后面的伪类确定动作，如 `a:hover {color: #FF00FF}`
- 部分伪类开始涉及动画的范畴，比如 `:hover` 用于定义鼠标移到指定元素上临时更改的样式，此时可以将伪类简单地理解为常见的动作或动画
- 有些还会细分伪类选择器和伪元素选择器，这里不做细分，只是罗列一下，有需要时再查文档
- `a:link`：选取所有未被访问过的链接，一般只用于链接
- `a:visited`：选取所有访问过的链接，一般只用于链接
- `:active`：元素活动时（鼠标在元素位置按下但并未释放时）被选取
- `:hover`：鼠标悬浮到指定元素时被选取
- `input:focus`：选取获取焦点的指定输入框，一般只应用于输入框
- `:first-child` : 一组兄弟元素中的第一个元素，注意可以同时选出多个第一个元素（注意是对前面一组元素做进一步筛选）
- `:nth-child`
- `:nth-last-child`
- `:nth-of-type`
- `:first-of-type`
- `:last-of-type`
- `:empty`
- `:target`
- `:checked`
- `:enabled`
- `:disabled`
- 其中 LVHA 四个为链接伪类选择器，一般用于对 a 元素设置样式：`a:hover` 必须在 CSS 定义中的 `a:link` 和 `a:visited` 之后，才能生效；`a:active` 必须在 CSS 定义中的 `a:hover` 之后才能生效，建议按 LVHA 顺序编写链接伪类顺序
- 对于 a 元素，指定颜色需要单独指定，对父级元素统一设置的颜色对 a 元素无效（浏览器为 a 元素设置了默认颜色，而继承的属性权重为 0 无法覆盖默认样式）
- 伪类名称对大小写不敏感

### 伪元素

- 伪元素选择器则一般用于描述无法用 HTML 语义表达的实体，例如某个元素之前、之后等，这个之前、之后的元素在 html 中并不存在，因此是个伪元素
- CSS3 中为了区别伪类，将伪元素的一个冒号改为两个冒号的形式，如 `::before`，因此对于伪元素，单个冒号是已过时的写法

## 补充

- 样式可以层叠，如果多于一个规则指定了相同的属性值都应用到一个元素上，CSS 规定拥有更高确定度的选择器优先级更高
- 例如，ID 选择器比类选择器更具确定度, 而类选择器比标签选择器（tag selector）更具确定度
- 如果样式中包含冲突的规则，且它们具有相同的确定度。那么，后出现的规则优先级高
- 若遇到规则冲突，可以增加其中一条的确定度或将之移到后面以使它具有更高优先级

# CSS 样式

- 样式的学习只是简单地列举一下常用的样式，具体的可以使用时再查阅文档

## 字体

- 字体属性主要用于设置和字体相关的样式，包括字体族、大小、粗细和文字样式等
- 字体族：font-family 用于设置元素内部的字体族，注意如果字体名称不止一个单词，则必须用引号引起来，例如："Times New Roman"
- 字体风格：font-style 用于设置元素内部的字体样式，默认值为 normal，可选值包括正常 normal，斜体 italic，倾斜 oblique（倾斜与斜体非常相似，但支持较少）
- 字体变形：font-variant 可用于用于将元素内部的小写字母转化为小型大写字母，默认值为 normal 表示不转换，设置为 small-caps 则表示转换为小型大写字母
- 字体加粗：font-weight 用于设置字体粗细，默认值为 normal，常用可选值包括 normal, bold, bolder, lighter 等，可使用整百数字 100 - 900，其中 400 等同于 normal，而 700 等同于 bold，注意不带单位
- 字体大小：font-size 用于设置字体粗细，推荐使用 em 单位或百分比；对于标题标签比较特殊，需要单独指定文字大小，在 h 元素外部的 div, body 等统一设置 font-size 对 h 元素无效
- 1em 等于当前元素内部的默认字体大小，浏览器中的默认文本大小为 16px，因此默认大小 1em 为 16px
- 字体复合属性：可以使用 font 属性统一设置字体的复合属性，但必须按照约定的顺序 `font: font-style font-weight font-size/line-height font-family`，不可随意更换顺序，其中 font-style, font-weight 和 line-height 可以省略，但 font-size 和 font-family 必须指定
```css
p {
    font: 12px 'Microsoft YaHei';
}
```
- 其中 line-height 属于文本属性，用于设置行高（从而设置间距）
- 对于标题元素，其字号、行高属性较为特殊，无法使用外部元素通用设置（浏览器对 h 设置了默认字号，而继承的样式权重为 0，无法覆盖默认样式），只能单独对指定元素单独设置


## 文本

- 文本属性用于设置和文本外观相关的样式，主要包括：文本颜色、对齐文本、装饰文本、文本缩进、行间距等
- 文本颜色：color 用于设置元素内部的文字颜色，无默认值
- 水平对齐方式：text-align 用于设置 block 元素内部元素的水平对齐方式，常用可选值有 left, center, right 等，对 inline 元素设置该值没有意义
- 文本装饰：text-decoration 用于设置文本的装饰，默认值为 none 表示无装饰，常用可选值包括下划线 underline、上划线 overline、删除线 line-through、闪烁 blink 等，其中 a 元素该属性的默认值为 underline，若需要取消则需要手动设置 a 元素的 text-decoration 属性
- 文本首行缩进：text-indent 设置文本的首行缩进，通常使用 `2em` 表示缩进两个字的宽度，还可以使用负值、百分比等值，示例：`p {text-indent: -5em;}`
- 行高：line-height 用于设置文本行高，一个完整的行高由 3 部分组成：上间距、文本高度、下间距，通过设置行高和文本高度来确定行间距大小
- 字间隔：word-spacing
- 字母间隔：letter-spacing
- 字符转换：text-transform
- 处理空白符：white-space
- 文本方向：direction

- 颜色可以使用十六进制 `color: #ffffff;`，rgb 格式 `color: rgb(255, 255, 255);` 或者 HSL 格式 `hsl(0, 100%, 50%);` 进行设置，此外对于常用颜色可以使用单词，如 `color: blue;`
- 垂直居中特殊处理方式：让文本的行高等于盒子的高度，由于上下间距自动平分，则可以达到垂直居中的效果
- 链接的颜色判定较为特殊，必须对 a 单独指定颜色才会生效，只设置外层的颜色不会生效（即 a 元素默认不会继承父元素的属性，类似标题的宽度）

## 背景

- 背景属性主要用于设置和背景相关的样式
- 背景颜色：background-color 用于设置背景颜色，其默认值为 transparent，表示透明，可以使用 `rbg(255, 255, 255)` 或 `#ffffff` 设置具体颜色值
- 背景图像：background-image 用于设置背景图像，默认值为 none， 可以使用 `url(image/logo.png);` 设置背景图片
- 背景平铺：在设置了背景图像时，background-repeat 可用于设置背景图像的平铺方式，默认值为 repeat 表示重复平铺，常见的取值包括重复平铺 repeat, 不平铺 no-repeat, 水平方向重复 repeat-x 和 垂直方向重复 repeat-y，分别对应各自的平铺方式
- 背景定位: 在设置了背景图像时，可使用 background-position 设置背景图片的方位，其可选值可以是方位名词 top, center, bottom, left 和 right 的组合，也可以是具体的百分比或者数值
  - 默认值为 0% 0%（=left top），即图片出现在左上角
  - 取值为方位名词时，则前后顺序无关，例如 left top 和 top left 的效果一致
  - 取值为方位名词时，若只写一个值而省略另一个值，则被省略的方位会被设置为 center
  - 取值为数值时，则第一个值表示 x，第二个值表示 y，若只写一个值而省略另一个值，则垂直方向会被当做 50%
  - 也可以使用混合单位，即其中一个采用数值，另一个采用方位名词，采用混合单位时，第一个为 x，第二个为 y
- 背景固定：使用 background-attachment 属性设置背景图像是否固定在指定区域或者随着滚轮滚动而滚动，默认值为 scroll 表示默认和其他元素一样会滚走，设置为 fixed 则表示将一直固定在指定区域
- 简写属性：使用 background 设置所有和背景相关的属性，顺序为 background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置; 例如 `body {background: transparent #00FF00 url(bgimage.gif) no-repeat fixed center top;}` 
- 背景色透明：CSS3 引入了 `rgba(0, 0, 0, 0.5)` 属性用于在设置颜色的同时设置透明度，透明度的取值范围为 0 - 1 之间

- 可以同时设置背景颜色和背景图片，但背景图片在更上一层，其会在有内容处覆盖背景颜色
- 和 img 元素相比，使用背景来引入和设置图片更加地方便，可以很方便地使用 background-position 来这是图片在水平和垂直方向的对齐方式





## 链接与列表

**链接**

- 链接有四种状态，可以用伪类选择器选择对应状态的样式
```css
a:link {color:#FF0000;}		/* 未被访问的链接 */
a:visited {color:#00FF00;}	/* 已被访问的链接 */
a:hover {color:#FF00FF;}	/* 鼠标指针移动到链接上 */
a:active {color:#0000FF;}	/* 正在被点击的链接 */
```
- a:hover 必须位于 a:link 和 a:visited 之后，a:active 必须位于 a:hover 之后
- 常见的链接修饰包括文本装饰、背景色更改等

**列表**

- 设置列表项的标志类型：`ul {list-style-type : square}`，无序列表中可能是圆点方块等，有序列表中，标志可能是字母、数字
- 还可以将列表项标志设置为某个图像：`ul li {list-style-image : url(xxx.gif)}`
- 

## 表格

- 设置边框使用 border 属性
```css
table, th, td{
    border: 1px solid blue;
}
```
- border-collapse 属性设置是否将表格边框折叠为单一边框，使得中间没间隙，且线不那么粗
- 表格内文本对齐使用 text-align，vertical-align 等
- 内边距使用 padding
- background-color 设置背景色，color 设置文本元素

## 列表

- 移除 li 前面默认小圆点：
```css
li {
    list-style: none;
}
```

## 轮廓

- 轮廓是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用
- outline-width 设置轮廓宽度
- outline-color 设置轮廓颜色
- outline-style 设置轮廓样式，如点状、实线、虚线等
- outline 在一个声明中设置所有的轮廓属性，简写属性
- outline 存在于 margin 区域，如果原来元素无 margin 会自动扩充


## CSS3 新样式

### 圆角矩形

- 使用 border-radius 设置圆角矩形：使用半径为 r 的圆去切除矩形的四个角，没被圆覆盖到的角落则会被切除，从而留下圆角，数值可以是像素值或百分比
- 对于 width 和 height 都等于 2r 的正方形，设置 border-radius 为 r ，则整个正方形变为圆，或者直接设置 `border-radius: 50%`
- 若对于矩形，要设置成椭圆，则必须使用百分比，设置 `border-radius: 50%`，固定数值暂时没找到方法
- border-radius 其实为简写属性，其从左上角开始，顺时针方向分别设置圆的半径来切除角落留下圆角

### 盒子阴影

- 使用 box-shadow 属性为盒子添加阴影，其语法格式为：`box-shadow: h-shadow v-shadow blur spread color inset`
- h-shadow 和 v-shadow 为必填项，分别设置水平、垂直阴影的位置，允许负值
- blur 设置模糊距离，spread 设置阴影尺寸，color 设置阴影颜色，inset 设置阴影内外模式
- 默认的是外阴影 outset，但是不可以写这个单词，否则导致阴影无效，若需要内阴影则设置为 inset
- 盒子阴影不会占用空间，不会影响其他盒子排列

### 文字阴影

- 使用 text-shadow 设置文字阴影，其语法格式为：`text-shadow: h-shadow v-shadow blur color`，其含义和 box-shadow 含义一致

# 元素显示模式

- 元素显示模式就是定义元素按什么方式显示：在 HTML 中有各种各样的元素，他们分别属于不同类型的元素，例如 div 单独占一行，而多个 span 可以共存在一行
- 根据标准，可将 HTML 元素划分为两大类：块级（block）元素和行内（inline）元素，可以使用 display 属性改变生成元素的类型

## 块元素 block

- 块元素自己单独占一行，其宽度默认会占满父元素的宽度并挤压兄弟元素
- 可以设置宽高和内外边距，但设置宽度后仍然会独占一行，并不是只占用设定的宽度
- 宽度默认是容器（父级宽度）的 100%
- 块元素可看做是一个容器/盒子，里面可以放置行内或者块元素

- 注意，文字类元素内部不能放块级元素，否则文字会被截断为两块，例如 p 元素内部放置 div 元素则段落会被截断为两对 p 元素
- 此外，把一些文本添加到一个块级元素（比如 div）的开头。即使没有把这些文本定义为段落，它也会被当作段落对待，这个框称为无名块框，因为它不与专门定义的元素相关联，对该无名框，无法应用样式

## 行内元素 inline

- 多个行内元素可以共存与一行
- 行内元素的宽高设置无效，其宽度默认为元素内容的宽度
- 行内元素只能容纳文本或其他行内元素，不能放置块元素

**特殊情况**

- a 元素内部不能再放置 a 元素
- 特殊情况下，a 元素内部可以放置块级元素，例如在 a 内部放置 img 元素，但这种情况下最好将 a 转换为块级模式则更加安全


## 行内块元素 inline-block

- 行内元素中，有几个特殊的元素：img, input, td，它们同时具有块级元素和行内元素的特点，故有的资料称它们为行内块元素
- 一行内可以有多个行内块元素，但它们之间会有一个空白的缝隙
- 默认的宽度就是其内容本身的宽度，但可以控制他的高度、宽度、内外边距（块级元素的特点）

## 显示模式的转换

- 当需要将一个元素的默认显示模式转换为另一种显示模式的特性时，可以使用 display 属性进行转换
- display 和显示模式相关的可选值包括：block, inline 和 inline-block


# CSS 特性

## 层叠性

- 层叠性指的是：当使用同一选择器语法，给某一元素的同一属性设置不同值时，则一个样式会覆盖（层叠）另一个样式，样式冲突时遵循就进原则，后面的会覆盖前面的
```css
div {
    color: red;
}

div {
    color: green;
}
```

## 继承性

- 在 CSS 中，子元素会继承父元素的部分样式，例如 font-size, color 等
- 一般支持继承的属性为文本类属性：text-, font-, line- 等开头的属性可继承；color 属性可继承
- 对于 a 元素和 h 元素，有部分属性较为特殊，无法继承，例如 h 元素的 font-size，a 元素的 color 都无法继承，必须单独对元素进行设置
- 对于行高的继承，最好不要设置固定值，而是设置为倍数，以避免子元素自行设置字号时导致行高不够，设置为倍数则子元素修改字号时，行高会自动设置为字号的倍数
```css
body {
    color: pink;
    font: 12px/1.5 'Microsoft YaHei';
}
```

## 优先级

- 当时用多种不同的选择器语法选择某一元素并设置样式时，不同的选择器语法会产生不同的样式优先级，从而产生覆盖
- 若选择器相同，则根据层叠性的就近原则执行
- 选择器不同，则根据选择器权重执行
- 选择器权重由 4 组数字组成，优先级从前往后逐组比较，若相同则继续比较后一组，直至遇到数字大的则为优先级高的，权重表如下表所示：

|选择器|选择器权重|
|:---:|:---:|
|继承或者 *|0,0,0,0|
|元素选择器|0,0,0,1|
|类选择器|0,0,1,0|
|id 选择器|0,1,0,0|
|行内样式|1,0,0,0|
|!imporant|无穷大|

- 在使用组合选择器时，必定产生权重的叠加，例如选择器 `ul li` 的权重为 `0,0,0,2`，选择器 `.nav li` 的权重为 `0,0,1,1`
- 权重的叠加不会产生进位，即使元素嵌套 11 层，其权重为 `0,0,0,10`，但优先级仍然低于类选择器 `0,0,1,0`
- 继承的权重是 0，如果该元素没有被选中，不管父元素权重多高，子元素得到的权重都是 0，这也是为什么必须为 a 的颜色属性、 h 的字号单独手动设置的原因，因为浏览器对这两元素都自动设置了样式，而若在外部统一设置样式，继承得到的权重为 0，无法覆盖浏览器单独设置的默认设置样式



# 盒模型

- 盒模型从里到外分别是 element、padding、border、margin
- 注意 padding, border 和 margin 会影响盒子的实际大小，因此一个盒子的实际占用大小为 width/height + padding + border + margin

## border

- boder 有 3 个属性可以设置：边框宽度 border-width、样式 border-style 以及颜色 border-color，可以使用 border 属性统一设置，例如 `border: 1px solid red;`，也可以分开设置，此外还可以单独设置某条边的样式（border-top-color，border-bottom 等）
- 需要注意的是 border-style 默认是 none ，这种情况下默认是不显示 border 的，即使设置了 border 的宽度和高度也不显示
- 此外，还可以设置带宽度的透明边框 `border-color: transparent;`
- 对于表格，还有 `border-collapse` 属性，其控制单元格的边框重合时的样式，一般设置为 `border-collapse: collapse` 表示合并相邻边框
- border 会影响盒子的实际大小：width 和 height 实际上设置的是内容的宽高，因而而边框会影响盒子的实际大小，因此其真正的宽高一般还要加上 border 的宽高

## padding

- padding 属性定义元素边框与元素内容之间的空白区域，可以设置为长度值或百分比值，但不允许使用负值，百分数值是相对于其父元素的 width 计算的
- 特别注意上下内边距的百分数也是相对于父元素宽度设置，而不是相对于高度
- 对于 4 个方向的值设置，CSS 定义了一些值复制的规则（padding、margin 一致）：使用 padding 复合属性设置值的时可以省略部分相同的，原理为从 top 开始顺时针设置，未设置的取对面的值，例如 `padding: 5px 10px 20 px;` 分别表示 padding-top, padding-right, padding-bottom 值为 5px, 10px, 20px，而 padding-left 由于未设置则和 padding-right 相同
- 若盒子设置了 width/height 属性，那么 padding 也会影响盒子的实际大小：width 和 height 实际上设置的是内容的宽高，因而 padding 会影响盒子的实际大小，使得盒子宽高从内容的 width 和 height 向外撑大，因此盒子的真正宽高一般还要加上 padding 值
- 但若盒子本身没有指定 width/height 属性，则此时 padding 不会撑开盒子大小，只会向内挤压；若指定了宽度和高度，则会向外撑开，例如对 div 设置 `width: 100%;` 并设置 padding，将导致水平滚动条出现

## margin

- margin 设置盒子外边距（即盒子与盒子间的距离），属性接受任何长度单位，还可以设置为 auto
- 和 padding 类似，当设置为百分数时，是相对于父元素的 width 计算的
- 为了照顾兼容性，对于行内元素，尽量只设置左右的内外边距，因为有些情况上下的内外边距无效

### 外边距典型应用：块级盒子水平居中

- 只要满足两个条件，可以让块级盒子水平居中：
- 盒子必须指定宽度 width
- 盒子的左右外边距设置为 auto，例如 `margin: 0 auto;`
- 注意该方法对行内元素和行内块元素无效，行内元素和行内块元素的水平居中需要通过为其父元素添加 `text-align: center;` 来实现

### 外边距合并

- 外边距合并指的是，当两个垂直外边距相遇时，它们将进行合并，合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者，主要包含两种情形：
- 一种是两个相邻的元素，上面元素的下边距和下面元素的上边距会进行合并，保留较大的
- 另一种情况是一个元素包含另一个元素时（即存在父子关系），子元素和父元素相邻且父元素没有 boder 或 padding 或内容分隔开时，则它们相当于拥有共同的 margin 计算线，因此 margin 也会发生合并，保留较大的，从而产生父元素的塌陷问题，因此解决方法有：
    - 为父元素定义上边框，例如 `border-top: 1px solid transparent;`
    - 为父元素定义上内边距，例如 `padding-top: 1px;`
    - 为父元素添加 `overflow: hidden;`，该种方式不会额外增加盒子大小
- 只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并

### 清除内外边距

- 网页各个元素默认都自带了不同的 padding, margin 值，而且不同的浏览器默认值也不一致，因此往往需要统一清除所有元素的内外边距以实现风格统一，即（下述代码往往为 css 的第一行代码）：
```css
* {
    padding: 0;
    margin: 0;
}
```


# 布局

- 网页布局的本质：使用 CSS 来摆放盒子，把盒子放到相应的位置

## 传统网页布局的三种方式

- CSS 提供了三种传统布局方式：普通流（标准流）、浮动和定位
- 我们前面学习的都是标准流布局，也是网页最基本的布局方式，但一个完整的网页一般都需要结合三种布局才能完成
- 标准流：标签按照规定好的默认方式排列，即块级元素独占一行，从上向下顺序排列，行内元素和行内块元素不独占一行，按照顺序从左到右依次排列，并可以使用 display 修改元素的显示模式，比如可以将 a 的 display 设置为 block 来表现得和块级元素一样，也可以把 display 设置为 none，让生成的元素根本没有框，且从文档中消失，不再占据文档中的空间
- 除非专门指定，否则所有框都在普通流中定位，普通流中的元素的位置由其在 HTML 中的位置决定
- 在普通流中，块级元素会独占一行，从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来
- 行内元素会在一行中水平摆放，可以使用水平内边距、边框和外边距调整它们的间距，垂直内边距、边框和外边距不影响行内框的高度 (因此，对行内元素建议只使用左右 margin 和左右 padding)


## 浮动

**浮动**

- 如何让多个块级盒子水平排列成一行？如何实现两个盒子的左右对齐？
- 为什么需要浮动：有很多的布局效果，标准流无法完成（例如上述两种情况），此时就需要利用浮动完成布局，因为浮动可以改变元素默认的排列方式
- 浮动最典型的应用：可以让多个块级元素一行内排列显示
- 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动
- 浮动：float 属性用于创建浮动框，将其向左或向右移动，直到其外边缘碰到浏览器或其他浮动框的边缘
- 浮动的特性：
    - 浮动元素会脱离标准流（脱标），不再保留原先的位置
    - 若多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列
    - 浮动元素具有行内块的特性，故行内元素浮动后也可以设置宽高，不需要转换显示模式
    - 浮动的盒子中间没有缝隙，是紧挨在一起的
- 为了约束浮动元素的位置，我们一般先用标准流的父元素排列上下位置，之后内部元素采取浮动排列左右元素，符合网页布局第一准则
- 网页布局第二准则：先设置盒子大小，再设置盒子位置
- 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流
- 很多情况下，标准流的父元素不方便给高度，在子元素浮动后，父元素的高度变为 0 不会被盒子撑开，后续的盒子就会占用父元素原有的位置，从而产生浮动问题，此时需要清除浮动
- 清除浮动的本质是清除浮动元素造成的影响：若父盒子本身有高度，则不需要清除浮动；清除浮动后，父盒子就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了
- 清除浮动，一般有下列 4 种方法：
- 额外标签法，也叫隔墙法：在最后一个浮动元素的末尾添加一个空的块级元素，并添加清除浮动类 `.clear {clear: left|right|both;}`
- 父级添加 `overflow: hidden` 属性
- 父级添加 after 伪元素：算是额外标签法的升级版
```css
.clearfix:after {
    content: "";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}

.clearfix {
    /* IE6、7 专有 */
    *zoom: 1;
}
```
- 父级添加双伪元素
```css
.clearfix:before, .clearfix:after {
    content: "";
    display: table;
}

.clearfix:after {
    clear: both;
}

.clearfix {
    /* IE6、7 专有 */
    *zoom: 1;
}
```

## 定位

### 定位基础

- 为什么需要定位？假如有下述布局需求：
    - 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子
    - 滚动屏幕时，有部分内容固定在屏幕的指定区域，不随屏幕滚动而滚动，例如搜索栏，会到顶部选项等
- 上述效果，使用浮动无法快速实现，此时需要定位来实现，定位可以让盒子自由地在某个盒子内移动位置或者固定在屏幕中的某个位置，并且可以压住其他盒子
- 定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子
- 定位允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置
- 定位 = 定位模式 + 边偏移，定位模式用于指定一个元素在文档中的定位方式，边偏移决定了该元素的最终位置


**position 属性**

- static : 元素框正常生成，块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中
- relative : 元素进行偏移，但仍然占据原有的空间
- absolute : 元素从文档流删除，并相对于包含块进行定位，包含块可以是文档中的另一个元素或者初始包含块
- fixed : 元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身
- 注意相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置

#### 相对定位

- 设置为相对定位的元素框会偏移某个距离，元素仍然保持其未定位前的形状，它原本所占的空间仍保留
- 如下属代码将导致新的位置相对原来的位置，上方 20 左方 30
```css
#box_relative {
    position: relative;
    left: 30px;  /*元素右移*/
    top: 20px;  /*元素下移*/
}
```
- 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框

#### 绝对定位

- 绝对定位使元素的位置与文档流无关，因此不占据空间
- 绝对定位从当前元素开始一直往上查找，直到找到第一个 relative 或者 absolute 的元素，然后相对它进行定位，若是一直都找不到，则最终直接相对 html 进行定位
- 简单来说，绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块




# 补充内容

## emmet 语法

### html 快速生成

- emmet 语法用法都为：输入简写格式的表达式，然后按 tab 键，则自动生成对应的完整代码
- 生成骨架：输入 ! 按 tab 即可生成 html 骨架
- 生成标签：输入标签名并按 tab 键即可生成对应元素对，例如输入 `div` 然后按 tab 键，可以生成 `<div></div>`
- 生成多个相同标签： `div*3` 生成 3 个 div 对
- 生成父子关系的标签：例如 `ul>li*3` 可以生成一个包含 3 个 li 的 ul
- 生成兄弟关系的标签：例如 `div+p` 生成 div 和 p 元素
- 生成带 id 或 class 的标签：使用 .demo 或 #two 即可，例如 p.demo, div#two
- 序号：当生成多个元素且类名、id 名依据序号编号时，可使用 `$` 表示序号，例如 `div.demo$*5`
- 自带文字：如果想自动生成的标签内部自带元素，则可以使用大括号，例如 `div{盒子$}*5` 生成 5 个 div 内容为 盒子x

### css 快速生成

- emmet 快速生成 css 的基本原则为：输入简写+值，按 tab 即可生成
- 例如 `w200` 生成 `weight: 200px;`，`lh26` 生成 `line-height: 26px;`


## 水平对齐

- 可以将左右的 margin 都设置为 auto 来对齐块元素，左右 margin 都设置为 auto，则浏览器会均等地分配可用的外边距，因而达到块级元素居中的效果
- 居中一般要配合宽度使用，如果不设置宽度，块级元素默认撑满父元素，谈不上居中，若使用了百分比元素，可以达到动态调整宽度并自动居中的效果
- 例如，下述代码使得目标元素宽度为父元素的宽的 50% 并能自动居中
```css
#div1 {
    margin: 0px auto;
    background-color: #dddddd;
    width: 50%;
    height: 100px;
}
```
- 也可以利用绝对定位进行左和右对齐，但注意绝对定位元素会被从正常流中删除，并且能够交叠元素
- 若使用上述方法，一般要对 body 元素的外边距和内边距进行预定义是一个好主意。这样可以避免在不同的浏览器中出现可见的差异
- 另外，也可以利用 float 来进行左对齐和右对齐
- 注意还要适当控制宽高，利用 max-height, max-width 等属性



## box-sizing

- box-sizing 属性用于盒子模型的宽高计算方式
- CSS 中，元素的 width 与 height 只会应用到这个元素的内容区，如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距，当我们实现响应式布局时，这个特点尤其烦人，box-sizing 属性可以被用来调整这些表现
- content-box 是默认值，即你定义的宽高是应用在内容上，不包括 padding
- border-box 则将盒子模型设置为 width 包括了 padding 的值，举个例子，如果你将一个元素的 width 设为 100px，那么这 100px 会包括的 border 和 padding，内容区的实际宽度会是 width - border - padding 的计算值，这使得我们更容易的去设定一个元素的宽高
- 一些专家甚至建议所有的 Web 开发者们将所有的元素的 box-sizing 都设为 border-box
```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
```


## CSS 属性书写顺序

- 建议遵循下述顺序书写 CSS 属性：
- 布局定位属性：display/position/float/clear/visibility/overflow（建议 display 写第一个，毕竟关系到模式）
- 自身属性：width/height/margin/padding/border/background
- 文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word
- 其他属性（CSS3）：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient...

## 页面布局整体思路

- 先确定页面的版心（可视区宽度），其通过测量得知
- 分析页面中的行模块（标准流），以及每个行模块中的列模块（浮动），即页面布局第一准则
- 对于一行的列模块采用浮动布局，一般先确定每个列的大小，之后确定列的位置满级页面布局第二准则
- 遵循先有结构，后有样式的原则，先编写 HTML 结构，结构永远是最重要的
- 先理清楚布局结构，再写代码，多写多积累



## 常用技巧

- 编写样式时，先从大局来看，再从微观去看。例如先查看整个页面文字的颜色、字号等通用属性，之后再逐一逐段设置样式
- 在实际开发中，导航栏一般不会直接使用 a 链接而是使用 li 包含链接 a 的做法，li + a 语义更加清晰，一看就是有条理的列表型内容，如果直接使用 a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易有被搜索引擎降权的风险，从而降低网站排名）


# 参考链接

- [W3School CSS](http://www.w3school.com.cn/), by W3School
- [MDNCSS](https://developer.mozilla.org/zh-CN/), by MDN
- [黑马零基础前端开发视频教程](https://www.bilibili.com/video/BV1pE411q7FU), by 黑马程序员