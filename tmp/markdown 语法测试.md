

# 1. 测试标题和段落：《春》

## 1.1 作品原文

盼望着，盼望着，东风来了，春天的脚步近了。

一切都像刚睡醒的样子，欣欣然张开了眼。山朗润起来了，水涨起来了，太阳的脸红起来了。

小草偷偷地从土里钻出来，嫩嫩的，绿绿的。园子里，田野里，瞧去，一大片一大片满是的。坐着，躺着，打两个滚，踢几脚球，赛几趟跑，捉几回迷藏。风轻悄悄的，草软绵绵的。

桃树、杏树、梨树，你不让我，我不让你，都开满了花赶趟儿。红的像火，粉的像霞，白的像雪。花里带着甜味儿；闭了眼，树上仿佛已经满是桃儿、杏儿、梨儿。花下成千成百的蜜蜂嗡嗡地闹着，大小的蝴蝶飞来飞去。野花遍地是：杂样儿，有名字的，没名字的，散在草丛里，像眼睛，像星星，还眨呀眨的。

“吹面不寒杨柳风”，不错的，像母亲的手抚摸着你。风里带来些新翻的泥土的气息，混着青草味儿，还有各种花的香，都在微微润湿的空气里酝酿。鸟儿将窠巢安在繁花嫩叶当中，高兴起来了，呼朋引伴地卖弄清脆的喉咙，唱出宛转的曲子，与轻风流水应和着。牛背上牧童的短笛，这时候也成天嘹亮地响着。

雨是最寻常的，一下就是三两天。可别恼。看，像牛毛，像花针，像细丝，密密地斜织着，人家屋顶上全笼着一层薄烟。树叶儿却绿得发亮，小草儿也青得逼你的眼。傍晚时候，上灯了，一点点黄晕的光，烘托出一片安静而和平的夜。在乡下，小路上，石桥边，有撑起伞慢慢走着的人，地里还有工作的农民，披着蓑戴着笠。他们的房屋，稀稀疏疏的在雨里静默着。

天上风筝渐渐多了，地上孩子也多了。城里乡下，家家户户，老老小小，也赶趟儿似的，一个个都出来了。舒活舒活筋骨，抖擞抖擞精神，各做各的一份事去。“一年之计在于春”，刚起头儿，有的是工夫，有的是希望。

春天像刚落地的娃娃，从头到脚都是新的，它生长着。

春天像小姑娘，花枝招展的，笑着，走着。

春天像健壮的青年，有铁一般的胳膊和腰脚，领着我们上前去

## 1.2 创作背景

该文创作时间大约在1933年间。此时作者朱自清刚刚结束欧洲漫游回国，与陈竹隐女士缔结美满姻缘，而后喜得贵子，同时出任清华大学中国文学系主任，人生可谓好事连连，春风得意。

## 1.3 作品鉴赏

### 1.3.1 主题思想

该文的主题思想即对自由境界的向往。朱自清当时虽置身在污浊黑暗的旧中国，但他的心灵世界则是一片澄澈明净，他的精神依然昂奋向上。朱自清把他健康高尚的审美情趣，把他对美好事物的无限热爱，将他对人生理想的不懈追求熔铸到文章中去。熔铸到诗一样美丽的语言中去。从而使整篇文章洋溢着浓浓的诗意，产生了经久不衰的艺术魅力。

《春》——在这篇“贮满诗意”的“春的赞歌”中，事实上饱含了作家特定时期的思想情绪、对人生及至人格的追求，表现了作家骨子里的传统文化积淀和他对自由境界的向往。1927年之后的朱自清，始终在寻觅着、营造着一个灵魂深处的理想世界——梦的世界，用以安放他“颇不宁静”的拳拳之心，抵御外面世界的纷扰，使他在幽闭的书斋中“独善其身”并成就他的治学。《春》描写、讴歌了一个蓬蓬勃勃的春天，但它更是朱自清心灵世界的一种逼真写照。朱自清笔下的“春景图”，不是他故乡江浙一带的那种温暖潮湿的春景，也不是北方城郊的那种壮阔而盎然的春景，更不是如画家笔下那种如实临摹的写生画，而是作家在大自然的启迪和感召下，由他的心灵酿造出来的一幅艺术图画。在这幅图画中，隐藏了他太多的心灵密码。

### 1.3.2 写作手法

朱自清的散文《春》充满了叙不完的诗情、看不尽的画意。他将人格美的“情”与自然美的“景”水乳交融在一起，创造了情与景会、情景交融的艺术境界。朱自清在这篇仅仅30个句子的简短散文中。运用了二十多处修辞手法，频率之高，令人惊诧。作品是以“春”贯穿全篇，由盼春、绘春、颂春三个部分组成，逐层深入、环环相扣。而作者正是以修辞格来作为《春》的“颜料”，淋漓尽致地描绘出那幅五彩缤纷的早春图。

**1、殷切盼春归**

“盼望着，盼望着，东风来了，春天的脚步近了。”作品一开头，作者就用了一个反复修辞格。“盼望”这一动词的反复使用。突兀、有力、急切地反映出人们期盼春天来临的迫切心情。紧接着，用一个“拟人”辞格，来传递春天的讯息。春，是人们所心仪的，是可感可知的，可爱可亲的。春天的脚步声，更是人们极为熟悉的。来了，近了，它是人们在历经三九寒冬之后所殷切期盼的。在此。作者写出了人们对春天的翘首企盼之情和迎接春天的万分欣喜之情。 [4] 

**2、热情绘春景**

“一切都像刚睡醒的样子，欣欣然张开了眼”用了“拟人”辞格。在作者的笔下，春风轻拂，大地回暖，万物复苏，仿佛一个“刚睡醒”的人，“欣欣然张开了眼”。初春，好一种淡淡的气息；初春，好一派朦胧的景象。“山朗润起来了，水涨起来了，太阳的脸红起来了。”其中，“太阳的脸红起来了”用了“拟人”辞格，将太阳人格化，既抓住了春天太阳的特征，表现了春阳的温暖，更展示出春阳内在的神韵。整个句子又构成排比句，“拟人”、“排比”的套用，从大处着笔，对山、水、太阳进行了粗线条的描画，简明地勾勒出初春的总轮廓。为下文深层次、多视角地描绘春景图做铺垫。尤其值得一提的是，朱自清用“朗润”描写的山，使山富有光泽、格外的洒脱。

“小草偷偷地从土里钻出来，嫩嫩的，绿绿的”用了“叠音”和“拟人”修辞格。“偷偷”、“钻”等词语将小草顽强的生命力传神地表现出来，正所谓，“一岁一枯”，“野火烧不尽，春风吹又生。”而这也象征了人类社会世世代代繁衍生息，且总是向着更美好、更高级的社会进化、演变。“园子里，田野里，瞧去，一大片一大片满是的”用的是“反复”(重复)修辞格。嫩绿的小草“一大片一大片”的，长满了园子和田野，视线所及之处都是这绿的世界，让读者感受到这春草绿得多么诱人，而且具有很强的层次感。“坐着，躺着，打两个滚，踢几脚球，赛几趟跑，捉几回迷藏”用的是“排比”修辞格。值此大地回暖时节。人们告别封冻了一冬的粉妆玉砌的世界，来到满是绿色的草坪“坐着，躺着”，沐浴着春阳，甚是惬意。和着和煦的微风，开展各种户外活动。锻炼身体，增强体质。使人得以保持精神饱满的状态。
“桃树、杏树、梨树，你不让我，我不让你，都开满了花赶趟儿”是“排比”、“连环”及“拟人”几种修辞格连用，将桃花、杏花、梨花的竞相开放描绘得非常生动、非常形象。“红的像火，粉的像霞，白的像雪”，将三个“比喻”修辞格连着使用。而这三个比喻句又组成排比句。作者从色彩的角度，将桃花、杏花、梨花描绘得多姿多彩，鲜艳夺目，而且非常逼真。确是花卉争荣，各不相让。这些个花儿，充满了生命的芬芳，也使整幅春景图的色彩更为丰富、润泽。

“花里带着甜味，闭了眼，树上仿佛已经满是桃儿、杏儿、梨儿”用的是“通感”和“排比”修辞格。“花”是视觉，作者把它移植到味觉，说是“带着甜味”。看着春华想到秋实——满树的“桃儿、杏儿、梨儿”，着实让人过足了喜获水果丰收之瘾。这样的想象不仅拓宽了描绘的视野，更从另一角度渲染了春花的可爱。“花下成千成百的蜜蜂嗡嗡的闹着。大小的蝴蝶飞来飞去”用的“拟人”修辞格。一个“闹”字。将蜜蜂人格化，非常贴切。这样的描写既表现出声响。隐含着一片喧闹沸腾，更寓意着一派春意盎然、生机勃勃的景象。“野花遍地是：杂样儿，有名字的，没名字的，散在草丛里，像眼睛，像星星，还眨呀眨的”是“比喻”的连用及“比喻”、“拟人”修辞格的套用。草丛里的野花“像眼睛，像星星，还眨呀眨的”，非常生动。正是这些小野花，与别的花儿一起组成春花大家族，将春天大地装扮得分外靓丽妖绕。

“‘吹面不寒杨柳风’，不错的，像母亲的手抚摸着你”是“引用”与“比喻”修辞格的套用。句子先引用了南宋志南和尚的诗句，用以状写春风的温暖、柔和，非常亲切可感。

春风“像母亲的手抚摸着你”用了“比喻”修辞格，这个比喻让人觉得非常亲切、非常生活化，容易勾起人们儿时的回忆，倍感母爱的温暖和伟大。“鸟儿将窠巢安在繁花嫩叶当中，高兴起来了，呼朋引伴地卖弄清脆的喉咙，唱出宛转的曲子，与轻风流水应和着。”此句用的是“拟人”修辞格。鸟儿都来“卖弄”歌喉，它们宛转的曲子“与轻风流水应和着”。作者以“鸟唱”等鸟儿欢快的表现，衬托出人们愉悦的心情，反映出春天给人们、鸟儿、大地上的一切生灵带来了欢愉。
“看，像牛毛，像花针，像细丝，密密地斜织着，入家屋顶上全笼着一层薄烟”用了“比喻”、“排比”和“拟人”修辞格。作者将连绵春雨比作牛毛、花针、细丝，这三个比喻连用构成了排比。接着，用一个“织”字，将春雨人格化，也将春雨描绘得异常的湿润。“树叶子却绿得发亮，小草也青得逼你的眼”是宽式的(非严格意义的)“对偶”。作者通过这种修辞手法，加深了春景图中树叶的“绿”和小草的“青”，使整幅图更加浓墨重彩。图中所描绘的树、草及其它植物，都呈现出一派生机和活力。

“乡下去，小路上，石桥边，撑起伞慢慢走着的人；还有地里工作的农夫，披着蓑，戴着笠的。”其中，“小路上，石桥边”“披着蓑．戴着笠”用的是“对偶”修辞格，将乡间的各式人等的活动描绘出来。撑起伞，走在小路上、石桥边的入，心情放松．正慢慢地体会着初春的细雨“斜织”；而农夫则为了当年的好收成，借着大好的春光，“披着蓑，戴着笠”在地里忙着。

“他们的房屋，稀稀疏疏的，在雨里静默着”用了“叠音”和“拟人”修辞格。此处的“叠音”体现了声音美和语感美。房屋“在雨里静默着”是将房屋人格化，将蛰伏了一冬的房屋描绘得更富有灵性，装点着烟雨初春的乡村。
“城里乡下，家家户户，老老小小，他们也赶趟儿似的，一个个都出来了”共用了三个“叠音”修辞。作者通过声音的繁复增进语感的繁复，借声音的和谐增强语调的和谐。

“舒活舒活筋骨，抖擞抖擞精神，各做各的一份事去”用了两个“反复”修辞格和一个“对偶”修辞格。“舒活”、“抖擞”两个词语的重复出现使前两个语段构成“排比”，有意识地突出“蛰伏”了一冬的人们不愿辜负大好的春光，正大步迈进春天，以十二分的热情，聚集十二万分的潜能，全身心地投入到各项工作中。“‘一年之计在于春’，刚起头儿，有的是工夫，有的是希望”是“引用”修辞格和“双关”修辞格的套用。农民抓住农时，忙于春耕春种，以使来年衣食无忧。其他行业的人们也抓住春天这一大好时机，通过一番努力，实现生活的美好愿景。

朱自清在贴近大自然、感悟大自然、描绘大自然的同时，赞美那些在大好春光里辛勤劳作、奋然向前的人们的思想情感。

**3、春之礼赞**

“春天像刚落地的娃娃，从头到脚都是新的。它生长着”将春天比作“娃娃”，是“比喻”和“拟人”兼用。春天原非像别的事物那样可知、可感、可触摸，但作者把它比作新生的娃娃后，就赋予了它新的生命。

“春天像小姑娘，花枝招展的，笑着，走着。”此旬兼用“比喻”和“拟人”，将春天比作“小姑娘”。春天渐渐长大，变成“花枝招展的”小姑娘。她亭亭玉立，落落大方，“笑着，走着”，着实招人喜爱。社会的发展、进步，将会使更多的少年儿童健康成长，这是人类社会的美好愿望。“春天像健壮的青年，有铁一般的胳膊和腰脚，领着我们上前去”是“比喻”和“拟人”兼用，将春天比作“有铁一般的胳膊和腰脚”的“青年”，有理想，有勇气，有作为，敢担当。春天这个“健壮的青年”，“领着我们上前去。”在此，作者纵情赞美春天。并迸一步揭示出：春天有着不可遏制的创造力和无限美好的希望。因此，应当踏着矫健的春天步伐，去创造更加美好幸福的新生活。

三个比喻句组成了“排比”修辞格。作者用三个形象化的比喻，渐次排比，讴歌春天，使作品气势迭起，也使整幅春景图更加丰润。作者还要以此印证：春天是新鲜、美丽、欢快、具有强大生命力的。作品以这三个比喻句收束全文，言简意赅，节奏明快，生动活泼，表现力极强。
纵观全篇，《春》鲜明地表现出田园牧歌式的清新格调和欢快情绪。它是一曲赞歌，唱出了春的美妙旋律；它是一首热情的诗，抒发了对春的企盼和眷恋；它是一幅优美的图画，展示出春的气息与魅力。

## 1.4 名家点评

> 现代散文家朱自清的白话散文对“五四”以后的散文作家产生过一定的影响。朱自清的散文可以说是诗的变体，具有诗的艺术特征。其中，《春》更是诗意盎然，以明快婉转的诗化语言、善于运用侧面烘托的诗歌表现手法、情景交融的诗化意境谱写了一曲春之赞歌。      ——殷玉香

## 1.5 作者简介

朱自清（1898年11月22日—1948年8月12日），原名朱自华，字佩弦，号秋实。原籍浙江绍兴，出生于江苏省东海县。现代散文家、诗人、学者、民主战士 [7]  。散文有《匆匆》、《春》、《你我》、《绿》、《背影》、《荷塘月色》《伦敦杂记》等，著有诗集《雪朝》，诗文集《踪迹》，文艺论著《诗言志辨》、《论雅俗共赏》等。


# 2. 测试列表与图文混排：《数据链路层》

- [数据链路层](https://www.cnblogs.com/zhangyinhua/p/7608173.html)
- 帧：**数据链路层的传输单元**，由一个数据链路层首部和其携带的封包所组成协议数据单元，头部表名数据发送者、接受者、数据类型
- MAC 地址：每个设备具有的硬件地址。数据链路层负责 MAC 地址，在网卡的 ROM 中
- 链路：是从一个结点到相邻节点的一段物理链路，**数据链路**则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）
- 无论在多么复杂的网络中，从逻辑意义上讲，真正的数据传输通道就是数据链路层中所定义的数据链路
- 数据链路层的三个基本问题是：**封装成帧**、**透明传输**和**差错检测**（可能还有物理地址寻址、流量控制、重发等）
- 循环冗余检验 CRC 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码
- 数据链路层使用的信道主要有两种：**点对点信道** 和 **广播信道**，对应的两种的常见的协议为：**点对点协议 PPP**与**以太网协议**
- **以太网协议**与**点对点协议 PPP** 均是数据链路层协议，区别在于以太网被设计用于广播网络，ppp 协议用于点对点网络，看帧格式就能明显看出区别来，以太网帧中有目标 Mac 地址，用于在多路信道确认目标端机器。而点对点协议中就没有目标 mac，点对点链路两端的主机事先就已经知道链路那头是哪个 ip 了
- 以太网采用的无连接、不可靠的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认，目的站收到有差错帧就把它丢掉，其他什么也不做

## 2.1 封装成帧

- 其实就是在帧的数据部分添加帧首部和帧尾部，帧首尾用于帧定界，而数据部分才是传递给上层的数据（即 IP 数据报）
- MTU：Maximum Transfer Uint，帧的数据部分的最大长度，即 IP 数据报长度
- 我们将帧首部记作 SOH，帧尾部记作 EOT，用于帧定界
- 帧的逻辑结构如下图所示，SOH、EOT 的具体内容则和具体协议有关，例如 PPP 协议和以太网协议有不同的帧格式
![帧结构图](https://raw.githubusercontent.com/h428/img/master/note/00000002.jpg)


## 2.2 透明传输

- 由于我们使用了帧定界符 SOH，EOT，但数据部分也有可能包含定界符，从而导致帧定界出错，因此需要实现透明传输
- 数据部分如果出现了 SOH，EOT，我们在其之前添加一个转义字符 ESC，这样就能将其识别为数据而不是帧定界符，如果数据部分也包含 ESC，则可以在 ESC 之前再添加一个 ESC ![透明传输](https://raw.githubusercontent.com/h428/img/master/note/00000003.jpg)
- 透明传输的方法主要有字节填充和零比特填充两种 

## 2.3 差错处理

- 差错产生的原因：数据信号从发送端发送到物理线路时，由于物理线路存在噪声，因此数据信号经过物理线路的噪声，到达接收端时，已经是数据+噪声的叠加，因此差错无法避免 
![差错](https://raw.githubusercontent.com/h428/img/master/note/00000004.jpg)
- 由于存在噪声，可能出现比特错误、帧丢失、帧重复和帧失序等错误
- 差错控制主要两种策略：检错和纠错
    - 检测码：发送冗余信息让接收端用于检错
    - 纠错码：发送足够的冗余信息让接收端能发现并自动纠错
- 由于纠错码实现比较复杂，检测码虽然不能纠错，但是足够简单，能够检测出差错，配合重传机制即可。所以广泛采用检测码
- 循环冗余检验（CRC）即为最常见的检错方式

## 2.4 循环冗余检验 CRC

- 为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术
- 其概念性运算如图所示 
![CRC校验概念](https://raw.githubusercontent.com/h428/img/master/note/00000005.jpg)
- CRC 校验举例如图所示 
![CRC校验举例](https://raw.githubusercontent.com/h428/img/master/note/00000006.jpg)

## 2.5 点对点协议 PPP

- 点对点协议 PPP 是数据链路层的一种协议，用于点对点信道，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议
- 简单：接收方每接收一个帧，就进行 CRC 检验，检验正确，就收下，否则就丢弃，它是不可靠传输，所以这就是简单的原因
- 用户计算机和 ISP 进行通信时使用 PPP 协议，例如 PPPoE 为宽带上网的主机使用的链路层协议（连着一条线，不用寻址）
- PPP 协议帧格式如下
![PPP帧格式](https://raw.githubusercontent.com/h428/img/master/note/00000007.jpg)
- F：即帧定界标志，规定为 0x7E，即 01111110
- A：下一个目的地的 MAC 地址，由于点对点无需 MAC 地址，因此固定位 FF，没什么用
- C：控制字段，固定位 03，没什么用
- 协议：2 字节，描述协议类型
    - 0x0021：PPP 帧的信息字段就是 IP 数据报
    - 0xC021：PPP 链路控制协议 LCP 的数据
    - 0x8021：网络层的控制数据
- FCS：用于 CRC 校验
- [透明传输](https://juejin.im/post/5e64c6136fb9a07cc97daade) 采用字节填充或者零比特填充（SONET/SDH链路时），异步传输时使用字节填充，同步传输时使用零比特填充

## 2.6 广播信道、以太网与局域网

### 2.6.1 概述与关系

- **以太网**：以太网是通信协议标准，该标准定义了在局域网（LAN）中采用的电缆类型和信号处理方法
- **局域网**：在较小范围内组建的网络，通过交换器什么的连接各个PC机，比如一个实验室，一栋楼，一个校园内，这都市局域网，拿网线将两台计算机连在一起，这也能算是局域网
- 区别：以太网是一种局域网，而局域网却不一定是以太网，大多数局域网就是采用了以太网的这个标准
- 在局域网中，就采用的是广播信道：就是一台PC机发送数据给另一台PC机，在同一个局域网中的计算机都能接收到该数据，这就像广播一样，所以这种就叫做广播信道

### 2.6.2 CSMA/CD协议（半双工通信）

- 局域网是用广播信道的方式去传送数据，那么就会遇到问题，如果在局域网内有两个pc机同时在其中传播数据呢？就会发生碰撞，使两个数据都失效，那么如何解决这个问题呢，使用 CSMA/CD 协议来解决这类问题
- CSMA/CD 可简单描述为：多址接入、载波监听、碰撞检测
- 多址接入：该协议为多址接入协议，许多站点以多址接入的方式链接在一根总线上，其实就是局域网中总线网这种形式
- 载波监听：发送前监听，就是在**发送数据前监听总线中是否有数据在传播**，如果有就不发送。就是用电子技术检测总线上有没有其他计算机发送的数据信号
- 碰撞检测：
    - 边发送边监听，在发送数据的中途也会监听总线中是否会有其它数据，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）
    - 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。 所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”
- 检测到碰撞之后的处理 :
    - 在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来
    - 每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送

**传播时延对载波监听的影响**

- 争用期：发生碰撞所需要的最迟时间，即 $2 \tau$
- 10 Mbps 的以太网标准规定连接的最大长度为 2500 m，对应的争用期为 51.2μs，则在争用期内 10 Mbps 的以太网可发送 64 字节数据，因此我们发送帧至少要大于 64 字节，否则协议无法检测出是否发生碰撞
- 对于 100 Mbps 以太网，由于速度增大，如果要保证发送帧的最短有效帧仍然为 64 秒，则我们需要将争用期变为原来的十分之一 5.12μs，因此百兆以太网允许最大连接长度要为 250 m，其争用期为 5.12μs，在争用期内最多发送 64 字节数据，因此仍然符合最短有效帧的定义
- 由此可见，以太网的速率越快，以太网的有效距离就越短，对于 1000 Mbps 的以太网，要么放弃 CSMA/CD 协议改用其他协议，若仍要使用该协议，为了在争用期内检测出碰撞，就要再一次减小最大有效传输距离变为 25 m；若不想减小距离，则只能考虑将最短有效帧变为原来百兆以太网的 10 倍
- 最短有效帧：64 字节，就是上面这样算的，发送了 64 个字节之后，肯定就不会发生碰撞，以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧
- 根据 MAC 帧的格式，还有目的 MAC 地址 6 字节、源 MAC 地址 6 字节、类型 2 字节、FCS 4 字节，因此以太网数据部分最短 46 字节，最长即 MTU = 1500 字节

**二进制指数类型退避算法**

- 确定基本退避时间，一般就是争用期 $2 \tau$
- 确定参数 `k = min(重传次数, 10)`
- 从整数集合 `[0, 1, ..., 2^k-1]` 中随机选取一个数，记作 r，重传所需要等待的时延就是 r 倍的基本退避时间($2 \tau \times r$)
- 当重传 16 次还不能成功则丢弃该帧，并向高层汇报

### 2.6.3 以太网

- 在局域网内部，以太网广播数据，并通过 MAC 地址确定目的方是否接受数据
- MAC 地址：48 bit，6 字节，前 3 个字节是由管理机构给各个厂家分配的，也就是说如果有厂家想生产网卡这类需要mac地址的东西，必须先像管理机构申请前三位字节; 所以网卡上的前三个字节就代表着某个厂家，后三个字节就是由厂家自己来设定的
- 每个网卡都拥有识别数据帧中 mac 地址的功能
- 以太网定义的数据帧格式如图所示 
![以太网帧](https://raw.githubusercontent.com/h428/img/master/note/00000008.jpg)
- 目的地址、源地址即 MAC 地址，类型为数据包的类型，数据部分即为 IP 数据包，FCS 用于 CRC 校验
- 开头的 8 个字节为前同步码（7 字节） + 帧定界（1 字节）
- 前同步码是为了让接收方有反应时间，在接受 MAC 帧后，并不能马上识别出帧开始定界符，没有那么快的反应分辨出来，所以需要在帧定界前面加同步码，使接收方有反应的时间
- 同步码都是 1010101010101 这样的 bit，前 7 个字节的同步码跟最后一个字节中的前 6 个bit位相同，只有最后两位不同，如图 
![前同步码](https://raw.githubusercontent.com/h428/img/master/note/00000009.jpg)


# 3. 测试笔记与代码混排

## 3.1 lt：连续子序列最大和，经典 dp

- 定义状态 `dp[i]` 表示 `a[i]` 为结尾的子序列最大和
- 则我们可以得到状态转移方程 $dp[i] = \max(dp[i-1] + a[i], a[i])$
- 因而最终结果 $res = max(dp[i])\ for\ all\ dp[i]$
- 实现代码如下：
```java
class Solution {
    public int maxSubArray(int[] nums) {
        
        // dp[i] : 以 a[i] 为结尾的最大连续子序列和
        // res = max(dp[i])
        
        int sum = nums[0],res = nums[0];
        
        // dp[i] = max(dp[i-1]+nums[i], nums[i])
        for (int i = 1; i < nums.length; ++i) {
            sum = Math.max(sum + nums[i], nums[i]);
            res = Math.max(sum, res);
        }
        
        return res;
    }
}
```

## 3.2 工具类

- 以自定义的 ClassUtil 工具类为例
```java
package com.demo.base.component.util;

import java.lang.reflect.Field;
import java.util.*;

/**
 * 实体工具类，通过反射打印实体和生成实例
 */
public class EntityUtil {

    // 不想随机生成值的列，比如 deleteTime, 外键等，因为这些列不能生成随机值，需要设置为 null
    private static Set<String> EXCLUDE_FIELD = new HashSet<>();

    static {
//        EXCLUDE_FIELD.add("enums");
    }

    public static String toString(Object obj) {
        if (obj == null) {
            return "null object";
        }

        try {
            // 首先获取对象的所有域，并确定他们的名称
            Class<?> objClass = obj.getClass();
            Field[] fields = objClass.getDeclaredFields();

            if (objClass == String.class) {
                return (String) obj;
            }

            // 添加类名和左括号
            StringBuilder sb = new StringBuilder();
            sb.append(objClass.getSimpleName()).append("{");
            // 取出域，拼接起来
            for (Field field : fields) {
                String fieldName = field.getName();
                field.setAccessible(true);
                sb.append(fieldName).append("=").append(field.get(obj)).append(", ");
            }
            // 删除最后两个字符并打上右括号
            sb.delete(sb.length() - 2, sb.length());
            sb.append("}");
            return sb.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String toString(Collection<?> objs) {

        if (objs == null) {
            return "[null list]";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("the size is ").append(objs.size()).append(", data is [\n");

        for (Object obj : objs) {
            sb.append(toString(obj)).append("\n");
        }
        return sb.append("]").toString();
    }

    public static <K, V> String toString(Map<K, V> map) {

        if (map == null) {
            return "{null map}";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("the size is ").append(map.size()).append(", data is {\n");

        for (Map.Entry<K, V> entry : map.entrySet()) {
            sb.append("{ key = ").append(entry.getKey())
                    .append(", value = ").append(entry.getValue())
                    .append(" }\n");
        }
        return sb.append("}").toString();
    }

    /**
     * 利用反射技术，输出对象的字符串，这样就不必为每个对象编写 toString 方法，方便开发
     *
     * @param obj 要打印的对象
     */
    public static void printString(Object obj) {
        System.out.println(toString(obj));
    }

    /**
     * 利用反射技术，输出集合中每个对象的字符串，这样就不必为每个对象编写 toString 方法，方便开发
     *
     * @param objs 集合
     */
    public static void printString(Collection<?> objs) {
        System.out.println(toString(objs));
    }

    public static <K, V> void printString(Map<K, V> map) {
        System.out.println(toString(map));
    }


    public static <T> T generateRandomOne(Class<T> clazz) {
        int num = (int) (Math.random() * 100); // 随机数
        return generateRandomOne(clazz, num);
    }

    /**
     * 利用反射技术，随机生成对象实例，其中 Id 列不设置，String 类型的列设置：为列名+随机数，整型直接设置为随机数
     *
     * @param clazz 目标类型的 Class
     * @param <T>   泛型 T，即目标对象类型
     * @return 返回生成的实例
     */
    public static <T> T generateRandomOne(Class<T> clazz, int num) {
        try {
            T obj = clazz.newInstance();

            Field[] declaredFields = clazz.getDeclaredFields();

            for (Field field : declaredFields) {

                String fieldName = field.getName();
                Class<?> fieldType = field.getType();

                // serialVersionUID 列跳过生成值
                if (field.getName().equals("serialVersionUID") || EXCLUDE_FIELD.contains(fieldName)) {
                    continue;
                }

                field.setAccessible(true);

                // 其他列，若是 String 类型，则根据 列名+随机数 进行赋值
                if (fieldType == String.class) {
                    // 字符串类型设置为：列名+随机数
                    field.set(obj, field.getName() + num);
                } else if (fieldType == int.class || fieldType == Integer.class) {

                    if (fieldName.equals("status")) {
                        // 是 status，估计是 byte，取模 128
                        field.set(obj, ((int) num) % 128);
                    } else {
                        // 若是整型，直接赋值
                        field.set(obj, num);
                    }
                } else if (fieldType == long.class || fieldType == Long.class) {
                    field.set(obj, (long) num);
                } else if (fieldType == double.class || fieldType == Double.class) {
                    field.set(obj, (double) num);
                } else if (fieldType == float.class || fieldType == Float.class) {
                    field.set(obj, (float) num);
                } else if (fieldType == boolean.class || fieldType == Boolean.class) {
                    field.set(obj, num % 2 == 0);
                } else if (field.getType() == Date.class) {
                    field.set(obj, new Date());
                }
                // 其他类型不设置，留空
            }
            // 返回生成的对象
            return obj;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```


# 4. 其他测试

## 4.1 测试数学公式

- 行内公式：$res = \sum_{i=1}^{n} a[i]$
- 测试多行公式 
$$
    res = \sum_{i=1}^{n} a[i]
$$
- 一般来说，KeTex 能支持上述两种比较简单的公式渲染，但下面的这种较为复杂的环境则需要 MathJax 的支持
- 线性代数提供了一种压缩、便捷的方式来描述线性方程（MathJax）：
$$
\begin{cases}
    \begin{align}
    4x_1-5x_2&=-13 \nonumber \\
    -2x_1+3x_2 &= 9 \nonumber
    \end{align}
    \ \Rightarrow \ 
    Ax=b，其中\ A = 
    \begin{bmatrix}
    4 & -5 \\
    -2 & 3
    \end{bmatrix}，\ b = 
    \begin{bmatrix}
    -13 \\
    9
    \end{bmatrix}
\end{cases}
$$

## 4.2 测试表格

### 4.2.1 简单表格

|比较项|RESTful|RPC|
|:---:|:---:|:---:|
|性能|略低|较高|
|灵活度|高|低|
|应用|微服务架构|SOA架构|

### 4.2.2 表头很窄但内容很多的表格

|比较项|RESTful|RPC|
|:---:|:---:|:---:|
|概念|REST代表表现层状态转移(representational state transfer)，由Roy Fielding在他的论文中提出。REST用来描述客户端通过某种形式获取服务器的数据，这些数据资源的格式通常是JSON或XML。同时，这些资源的表现或资源的集合是可以修改的，伴随着行为和关系可以通过多媒体来发现|RPC代表远程过程调用(remote procedure call)，其中最著名的便是由Facebook开发，现在由Apache维护的Thrift(感谢Facebook为开源社区做出的伟大贡献)，其包含多种语言的实现。由于我们痛恨XML的数据格式繁杂，所以大多数RPC协议都是基于JSON|
|灵活度|高|低|
|应用|微服务架构|SOA架构|


### 4.2.3 表头很多的表格

|比较项|数据列1|数据列2|数据列3|数据列4|数据列5|数据列6|数据列7|数据列8|数据列9|数据列10|数据列11|数据列12|数据列13|数据列14|数据列15|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|记录 1|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|
|记录 2|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|
|记录 3|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|数据值|