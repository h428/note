
# 问题描述

求 a 的 n 次方

# 求解思路

- 常规解法，时间复杂度为 O(n)
- 快速幂有递归解法和非递归解法
- 其中，递归解法基于分治的思想：递归求解一半规模的幂，然后将结果 × 2，每次可以避免计算一半规模
- 非递归解法，则是以迭代的形式实现，思路可参考代码中的注释，我们使用一个例子说明思路：
    - 以计算 a^11 为例讲解迭代解法，首先 11 的二进制位 1011
    - 则 a^11 可以分解为：1×a^8 × 0^a^4 × 1×a^2 + 1×a^1
    - 显然，迭代取出指数 n 的最后一位(n&1，体现奇偶性)，若是 1，则乘以当前项
    - 每次迭代都要更新当前项（即使 n&0 为 0），分别为 a^1,a^2,a^4,...，并使 n>>1，这样下次才能取出新的最后一位
    - 累积出所有最后位是 1 的项，即可得到解

# 递归解法代码

```C++
#include <bits/stdc++.h>
using namespace std;

/**
 * 快速幂 递归解法
 * @param a
 * @param n
 * @return
 */
int power(int a, int n){

    // 递归出口，若指数为 1 直接返回 n
    if (n == 1){
        return a;
    }

    int powerLeft = power(a, n/2);

    int res = powerLeft * powerLeft;

    if (n & 1){
        // 奇数还要额外乘一个 a，因为奇数时，只计算了 a^(n/2)*a^(n/2) = a^(n-1)
        res *= a;
    }
    return res;
}

int main()
{
#ifdef _LOCAL
    freopen("E:/in.txt", "r", stdin);
#endif // _LOCAL

    // 计算 a^n 的幂
    // 分：递归计算左半边的幂
    // 合：若是偶数个，左边结果直接乘以左边结果，返回，若是奇数，还要额外乘以一个 a 然后返回
    // 递归出口：若指数为 1 则直接返回 a

    int res = power(10, 3);

    printf("%d\n", res);

    return 0;
}
```

# 非递归解法代码

```C++
#include <iostream>

/**
 * 快速幂的非递归解法
 * @param a 底数
 * @param n 指数
 * @return 返回快速幂结果
 */
int power(int a, int n){

    int ans = 1;
    int item = a; // 第一项的 item
    while (n){
        if (n & 1){
            // 若最后一个二进制位为1，则将当前项累积到总的
            ans = ans * item;
        }
        // 右移一位，相当于除以2
        n >>= 1;
        // 计算下一项，项的顺序为 a^1, a^2, a^4, a^8, a^16 ...
        item = item * item;
    }
    return ans;
}




int main() {

    // 快速幂 - 迭代法思路，计算 a ^ n
    // 将指数 n 分解为二进制，得到 f_p-1,f_p-2,...,f_1,f_0
    // 则 n = f_0*2^0 + f_1*2^1 + f2*2^2 + ... + f_p-1*2^(p-1)
    // 则 a ^ n = a^(f_0*2^0 + f_1*2^1 + f2*2^2 + ... + f_p-1*2^(p-1))
    //          = a^(f_0*2^0) * a^(f_1*2^1) * ... a^(f_p-1*2^(p-1))
    //          = f_0*a*(2^0) * f_1*a^(2^1) * ... f_p-1*a^(2^p-1)
    // 因此，我们可以每次迭代，每次计算新的项，并累加求得结果
    // 每次计算新的项时，都要用到之前的项

    // 以 a^11 为例，11 的二进制位 1011，则 a^11 = 1*a^(2^3) + 0*a^(2^2) + 1*a^(2^1) + 1*a^(2^0)
    // = a^8 + a^2 + a
    // 显然，后一个 item 的指数是前一个 item 指数的两倍，
    // 因此，每次迭代，计算出最后一位二进制（体现奇偶性），若是 1(奇数)，则将当前项累加到总和
    // 若是 0，则不必累加，之后右移一位（相当于除以2）

    int ans = power(10, 6);
    printf("%d\n", ans);

    return 0;
}
```