

# 问题

- 求解一个表，该表标记了哪些数是素数，哪些数是合数
- 常规算法判断一个数是否为素数，复杂度为 O(n^2)，若是内循环开根号，约为 O(n^1.5)，则对于该问题，常规的解法时间复杂度为 O(n^2.5)-O(n^3)

# 求解思路

- 素数线性筛的核心思想是：默认整个序列都为素数，然后从前往后遍历，用前面的数筛去后面的合数，比如用 3 筛去 合数 6,9，4 筛去合数 8，5 筛去合数 15，6 筛去合数 12
- 需要注意：理论上任何一个数可以筛去它的所有倍数，但实际上算法不可能这么运行，而是采用让某个数只能筛去以这个数为最大因子的合数，而不是所有倍数
- 例如：以 6 为例，以 12 的最大因子是 6，因此，12 可以用 6 筛去，但注意 18 不能用 6 筛去，那我们遍历到 6 时，如何求解得 12 且避免求解得18呢？
- 首先，明确：根据定义，合数可以分别为多个素数相乘
- 若当前数 m 是素数，m 不再可分解，此时最小素因子 k_min = m，k 为 区间\[2, k_min\]的所有素数，则 m 可以筛去 所有的 k×m，以 7 为例：k_min = 7, k = 2,3,5,7，则 m 能够筛掉合数为：14,21,35,49
- 若当前数m是合数，m必定可以分解为多个素数相乘，m=c1×c2×...，确定这些素数中最小的一个 k_min，k 为 区间\[2, k_min\]的所有素数，则 m 能筛去所有的合数 k×m，以 12 为例，12 含有素因子 2,3，k_min = 2, 则 k  = 2， 12 能筛去 24
- 为什么要找最小素因子：由于m是合数，m=c1×c2×...，假设选择的 k_min 不是最小素因子，那么 k_min 至少比 c1,c2,... 序列中的一个大，记序列中最小的为 c_min，用 k_min×m = k_min×(c1×c2×c_min×...) = c_min×(k_min×c1×c2×...)，(k_min×c1×c2×...) 必然大于当前合数 m，那么 k_min×m 肯定不能用当前的 m 筛去，要用这个较大的合数 (k_min×c1×c2×...) 筛去 
- 仍然以 6 为例：6 有因子 2,3，假设我选择大的因子 3 作为 k_min, 则 6 筛去的合数 ：k_min × m = 3 × m = 3 × 2 × 3 = 9 × 2，由于3不是最小，我们显然能得到一个更大的 9 来筛去 6×3
- 因此，结论就是：一个数 m，确定出最小素因子 k_min，k 遍历从 2 到 k_min 的所有素数，m 能筛去所有的 k×m
- 由于需要求解某个素的最小素因子，因此需要将素数单独存储在一个数组中，对数 m ，遇到第一个能整除的素数即为最小素因子


# 代码

```C++
/**
 * 素数线性筛
 * @param isPrime 素数标记数组
 * @param primeArr 素数序列，2,3,5,7,11,13,...
 * @param maxn 素数范围
 * @return 返回最终求得的素数个数
 */
int getPrime(bool* isPrime, int* primeArr, const int maxn){

    // 全部标记为素数
    memset(isPrime, 1, maxn);
    // 记录素数个数
    int primeNum = 0;

    for (int m = 2; m < maxn; ++m) {
        // 当前数是否素数已经在之前使用更小的数筛得，由于需要求最小素因子，故还需单独将素数记录下来
        if (isPrime[m]){
            // m 是素数，将 m 记录到素数序列中
            primeArr[primeNum++] = m;
        }
        // 利用当前数 m 筛去所有的满足条件的合数 km
        for (int i = 0; (i < primeNum) && (primeArr[i] * m < maxn); ++i) {
            // k 从第一个素数 2 开始按序列遍历素数序列，筛去所有的满足条件的 km
            int k = primeArr[i];
            isPrime[k * m] = 0;
            if (m % k == 0){
                // m 能整除该素数，说明找到最小素因子，跳出循环
                break;
            }
        }
    }
    return primeNum;
}
```


