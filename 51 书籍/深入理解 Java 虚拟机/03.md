
# 1. 概述

- GC 的历史比 Java 久远，1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言
- 关于 GC，主要思考三件事情 :
    - 哪些内存需要回收
    - 什么时候回收
    - 如何回收
- 我们已知，程序计数器、虚拟机栈和本地方法栈 3 个区域岁线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出有条不紊的执行入栈和出栈操作
- 每一个栈帧中分配多少内存基本上是在类结构确定时就已知（大小应该主要和方法的参数列表有关，尽管在运行期会由 JIT 编译器进行一些优化，但在基于概念模型的讨论中，大体上可以认为是编译器可知的），因此这几个区域的内存分配和回收都具备确定性，不需要过多地考虑回收的问题，因为方法结束或者线程结束时，内存就自然地跟着回收了
- 而对于 Java 堆和方法区这两个内存区域则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，因此这两个区域的内存分配和回收都是动态的，垃圾收集器主要处理这两个区域的内存回收

# 2. 对象已死吗

- 垃圾收集器在对堆进行回收前，首先要确定哪些对象还活着，哪些对象已经死去（即不可能再使用的对象）

## 2.1 引用计数法

- 引用计数法 (Reference Counting) : 给对象添加一个引用计数器，每当有地方引用它时，计数器就加 1；当引用失效时，计数器就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的对象
- 引用计数法实现简单，判定效率也高，在大部分情况下它都是一个不错的方法（类似 C++ 中的智能指针），也有一些著名的应用案例 ...
- 主流的 Java 虚拟机并没有选用引用计数法来管理内存，主要的原因是它很难解决对象之间相互循环引用的问题
- 运行下列测试代码，两个对象互相循环引用，观察能否被垃圾收集器回收，注意通过参数打印垃圾回收详情 :
```java
/**
 * testGC() 方法执行后， objA 和 objB 是否会被 GC 呢？ <br/>
 * -XX:+PrintGCDetails 打印 GC 日志
 */
public class ReferenceCountingGC {

    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    // 该字段的作用是占点内存，以便能在 GC 日志中看清楚是否被回收
    private byte[] byteSize = new byte[2 * _1MB];

    public static void testGC() {
        // 创建两个对象
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        // 两个对象在内部互相引用
        objA.instance = objB;
        objB.instance = objA;

        // 然后设置局部变量为 null
        objA = null;
        objB = null;

        // 假设在这行发生 GC，objA 和 objB 能否被回收？（如果采用引用计数法是不能的，因为它们内部还互相指向着）
        System.gc();
        
        // 可在此处打断点查看
    }

    public static void main(String[] args) {
        ReferenceCountingGC.testGC();
    }
}
```
- 经过测试，可以发现发生了垃圾回收，jvm 并没有因为两个对象保留互相引用而不进行回收，这说明 jvm 采用的并不是引用计数法

## 2.2 可达性分析算法

- 主流的商用程序语言的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的
- 该算法的基本思路为 : 通过一系列称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索的走过的路径称为引用链（Reference Chain），当一个对象从 GC Roots 到这个对象不可达时，则说明此对象是不可用的
- 在 Java 语言中，可以作为 GC Roots 的对象包括 :
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象
    - 方法区类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中 JNI （以 Native 方法）引用的对象

## 2.3 再谈引用

## 2.4 生存还是死亡

## 2.5 回收方法区


# 3. 垃圾收集算法


- [参考](https://dsxwjhf.iteye.com/blog/2201685)

# 4. HotSpot 的算法实现

# 5. 垃圾收集器

# 6. 内存分配与回收策略