

# 1. 概述

- 介绍 jvm 内存的各个区域
- 讲解这些区域的作用、服务的对象、可能产生的问题


# 2. 运行时数据区域

- 根据《Java 虚拟机规范》的规定，jvm 管理的内存会包含下述几个运行时区域
    - 程序计数器 (Program Counter Register)
    - 虚拟机栈 (VM Stack)
    - 本地方法栈 (Native Method Stack)
    - 堆 (Heap)
    - 方法区 (Method Area)
- 此外还有单独提出来的运行时常量池(Runtime Constant Pool)，其在实现上是方法区的一部分
- 此外还有直接内存(Direct Memory)，其并不是虚拟机运行时数据区域的一部分，也不是 jvm 规范中定义的区域，不由 jvm 管理
- 其中，方法区和堆是所有线程共享的数据区，而虚拟机栈、本地方法栈、程序计数器是线程隔离的数据区

## 2.1 程序计数器 (Program Counter Register)

- 程序计数器是一个较小的内存空间，可看做是当前线程所执行的字节码的行号指示器，因此，其显然是线程隔离的
- 在 VM 概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令（和 OS 中的程序计数器概念一致），分支、循环、跳转、异常处理、线程恢复等基础功能都是通过这个计数器来完成的
- Java 虚拟机的多线程是通过线程轮流切换并分配处理器的执行时间的方式来实现的，任何一个确定时刻，一个处理器（对多核处理器来说是一个核心）都只能执行一条线程中的指令，因此，为了线程切换后能继续上次的执行，每个线程都需要有自己独立的程序计数器，用于记录执行位置，各个线程之间的计数器互不影响，独立存储，这类内存区域称之为“线程私有”的内存
- 如果线程在执行的是 Java 方法，程序计数器存储的就是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这该计数器值为空（Undefined）
- 该内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域


## 2.2 Java 虚拟机栈 (Java Virtual Machine Stacks)

- 和程序计数器一样，也是线程私有的，生命周期与线程相同
- 虚拟机栈描述的是 Java 方法调用的内存模型 : 每个方法在调用的同时会创建一个栈帧 (Stack Frame) 用于存储**局部变量表**（局部变量表详细可参考补充内容）、操作数栈、动态链接、方法出口等信息
- 这里的栈帧就是栈中的一个元素 : 用于描述方法调用所需的基本信息等
- 每一个方法调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
- 通常有人将 Java 内存区域粗糙地划分为堆内存 Heap （存对象）和栈内存 Stack（存局部变量和引用），这也是大多数程序员最关注的、与对象内存分配关系最密切的两块内存区域，这种分法下的对内存就是堆，而栈内存就是本小节的 Java 虚拟机栈，或者说是Java 虚拟机栈中局部变量表部分，但实际上 Java 内存区域的划分远比这复杂
- 局部变量表存放了（详细可参末尾的补充内容） : 
    - 编译期可知的各种基本数据类型 (boolean, byte, char, short, int, float, long, double)
    - 对象引用类型 : 注意不是对象，只是一个指向对象起始地址的引用指针，或是指向一个代表对象的句柄或其他与此对象相关的位置
    - returnAddress 类型 : 指向一条字节码指令的地址
- 其中 64 为长度的 long 和 double 会占据两个局部变量空间 (Slot)，其余数据类型只占用一个
- 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，且在方法运行期间不改变局部变量表的大小
- 由于虚拟机栈线程独立，而局部变量通过栈帧存在这个区域中，因此显然方法中的局部变量也是线程独立的（但他们指向的对象则不一定）
- 在 Java 虚拟机规范中，对该区域规定了两种异常状况 :
    - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常（一次函数调用使得栈深度+1，函数调用完成会使得栈深度-1，无递归出口的递归函数就会导致该异常）
    - 如果虚拟机可以动态扩展（当前大部分的 jvm 都可动态扩展，只不过 Java 虚拟机规范中也允许设置固定长度的虚拟机栈），但扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常（这种情况往往是内存已经耗尽）

## 2.3 本地方法栈 (Native Method Stack)

- 本地方法栈与虚拟机锁发挥的作用是非常相似的，它们的区别就是虚拟机栈为虚拟机执行的 Java 方法（也就是字节码）服务，而本地方法栈则为使用到的 Native 方法服务
为虚拟机使用到的 Native 方法服务
- 虚拟机规范中没有对本地方法栈中方法使用的语言、方式、数据结构做强制规定，具体的 jvm 可以自由实现它，甚至有的虚拟机（譬如 Sun HotSpot 虚拟机）就直接将本地方法栈和虚拟机栈合二为一
- 和虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 异常和 OutOfMemoryError 异常

## 2.4 Java 堆 (Java Heap)

- Java 堆是 jvm 所管理的内存中最大的一块，其是被所有线程共享的区域，在虚拟机启动时创建
- 此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这儿分配内存
- Java 虚拟机规范中的描述 : 所有的对象实例以及数组都要在堆上分配
- 但随着 JIT 编译器的发展与与逃逸分析技术逐渐成熟，栈上分配、标量替换等优化技术将导致一些微妙的变化，所有的对象都分配在堆上也不是那么绝对了
- 在 Java 编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把 Java 的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序
- Java 堆是垃圾收集器管理的主要区域，因此很多时候也称作 "GC 堆"
- 从内存回收角度审视 : 现在收集器基本都采用分代收集算法，因此 Java 堆还可以细分为新生代和老年代； 再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间
- 从内存分配角度审视 : 线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer, TLAB)
- 不论如何划分，存储的仍然都是对象实例，进一步划分的目的是为了更好的回收内存和分配内存
- 根据 Java 虚拟机规范的约定，Java 可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们磁盘空间一样
- 实现时，可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的，通过 -Xmx 和  -Xms 控制
- 若堆中没有内存完成实例分配，且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常

## 2.5 方法区 (Method Area)

- 方法区与 Java 堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
- 虽然 Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但它却有一个别名叫做 Non-Heap（非堆），目的是为了和 Java 堆区分开来
- 对于习惯在 HotSpot 虚拟机上开发、部署应用程序的开发者来说，很多人都更愿意将方法区称作“永久代”(Permanent Generation)
- 本质上二者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队选择将 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样 HotSpot 的垃圾收集器可以像管理 Java 堆一样管理方法区，这样可以省去专门为方法区编写内存管理和垃圾回收的代码，对于其他虚拟机（如 BEA JRockit、IBM J9 等）是不存在永久代的概念的
- 类信息、常量、静态变量、即时编译器编译后的代码
- 堆的一个逻辑部分，别名又叫非堆，有时称为永久代，但本质上并不等价
- 仅仅 HotSpot 选择将 GC 分代收集扩展至方法去，或者说使用永久代来实现方法区
- 其他虚拟机则不存在永久代的概念
- 原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束
- 但使用永久代来实现方法区，其实不是一个好主意，因为更容易遇到内存溢出问题（永久代有 -XX:MaxPermSize 的上限，J9 和 JRockit 只要没有触碰到进程可用内存的上限，例如 32 位系统中的 4GB，就不会出现问题），而且有极少数方法（例如 String.intern()）会因为这个原因导致不同虚拟机下有不同的表现
- 因此，对于 HotSpot 虚拟机，官方也有废弃永久代并逐步改用采用 Native Memory 来实现方法区的规划了
- 在目前已经发布的 JDK 1.7 的 HotSpot 中，已经把原本放在永久代的字符串常量池移出
- Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不识闲垃圾回收，相对而言，垃圾回收行为在这个区域是很少出现的
- 但并未数据进入了方法去就如永久代的名字一样“永久”存在了，该区域内存回收的主要目标是针对常量池的回收和对类型的卸载，虽然回收条件非常苛刻，但确实是有必要实现回收的
- 根据 Java 虚拟机规范的规定，当方法区无法满足内存分配的需求时，将抛出 OutOfMemoryErrorError 异常

## 2.6 运行时常量池 (Runtime Constant Pool)

- 运行时常量是方法区的一部分
- Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放便一起生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放
- jvm 对 Class 文件的每一部分（包括常量池）的格式都有严格的规定，每一个字节用于存储哪些数据都必须符合规范上的要求才会被虚拟机认可、装载和执行
- 但对于运行时常量池，Java 虚拟机规范没有做任何细节要求，不同的虚拟机可以按照自己的需求来实现这个内存区域
- 不过，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中
- 运行时常量池相对于 Class 文件常量池的另一个重要特征是具备动态性，Java 语言并不要去常量一定只有编译期才能产生，也就是并非只有 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法
- 运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常

## 2.7 直接内存（Direct Memory）

- 直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，也可能导致 OutOfMemoryError 异常
- JDK 1.4 新加入了 NIO (New Input/Output) 类，引入了一种基于通道 (Channel) 与缓冲区 (Buffer) 的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作
- 这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据
- 直接内存的分配不受到 Java 堆大小的限制，但是受到本机总内存大小以及处理器存智空间的限制
- 服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 OutOfMemoryError 异常

# 3. HotSpot 虚拟机对象探秘

- 基于 HotSpot 虚拟机和常用内存区域 Java 堆为例，深入讨论 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程

## 3.1 对象的创建

- 虚拟机遇到一条 new 指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过
- 如果没有，那必须执行相应的类加载过程（第 7 章）
- 在类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等用于把一块确定的大小的内存从 Java 堆中划分出来
- 指针碰撞 (Bump the Pointer): 如果 Java 堆中的内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就仅仅是把那个指针像空闲空间那边挪动一段与对象大小相等的距离
- 空闲列表 (Free List): 如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
- 选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的的垃圾回收器是否带有压缩整理的功能决定
- 在使用 Serial, ParNew 等带 Compact 过程的回收器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的回收器时，通常采用空闲列表
- 除如何划分空间外，还要考虑对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况，该问题有两种解决方案 :
    - 一是对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性
    - 另一种是把内存分配的动作按照线程划分在不同空间中进行，即为每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），哪个线程要分配内存就在该线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时才需要同步锁定
    - 可以通过 `-XX:+/-UseTLAB` 参数设定虚拟机是否使用 TLAB
- 内存分配完成后，虚拟机将分配到的内存空间全部初始化为零（不包括对象头），如果使用 TLAB，这一工作过程可以提前至 TLAB 分配时进行，该步骤保证了对象的字段在 Java 代码中不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的的零值
- 接下来，虚拟机进行必要的设置，包括 :
    - 对象是哪个类的实例
    - 如何找到类的元数据信息
    - 对象的哈希码
    - 对象的 GC 分代年龄等
- 这些信息存储在对象头 (Object Header) 之中，根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式
- 上述工作完成后，从虚拟机的视角看，一个新的对象已经产生了，但从 Java 程序的视角看，对象创建才刚刚开始，`<init>` 方法还没有执行，所有的字段都还为零
- 一般来说，在执行 new 指令后悔接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完安全产生出来

## 3.2 对象的内存布局

- 在 HotSpot 虚拟机中，对象在内存中可以分为 3 块区域 : 对象头 (Header)、实例数据（Instance Data）和对齐填充（Padding）

**对象头**

- HotSpot 虚拟机的对象头包括两部分信息
    - 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等
    - 第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过该指针来确定这个对象时哪个类的实例
- 第一部分数据的长度在 32 位和 64 位的虚拟机中分别为 32 bit 和 64 bit，官方称它为 “Mark Word”
- 实际上，对象需要存储的运行时数据很多，已经超出了 32 位和 64 位结构所能记录的限度，但是对象头的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间
- 例如，当对象处于未被锁定的状态下， 25 bit 用于存储哈希码， 4 bit用于存储对象分代年龄，2 bit 用于存储锁标志位， 1 bit固定为 0
- 对于第二部分数据，并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要警告对象本身
- 另外，如果对象是一个 Java 数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据确定 Java 对象的大小，但是从数据的元数据中无法确定数组的大小

**实例数据**

- 实例数据部分是对象真正存储的有效信息，即代码中定义的各字段的内容
- 无论是从父类继承下来的，还是在子类中定义的，都需要记录起来，这部分的存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响
- HotSpot 虚拟机默认的分类策略为 longs/doubles, ints, shorts/chars, bytes/booleans, oops(Ordinary Object Pointers)
- 从分配策略中可以看出，相同宽度的字段总是被分配到一起，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前
- 如果 CompactFields 参数值为 true（默认为 true），则子类中教窄的变量也可能会插入到父类变量的空隙之中

**对齐填充**

- 第三部分对齐填充不是必然存在的，也没特别的含义，仅仅起着占位符的作用，和结构体中的概念一致（HotSpot 默认是 8 字节的整数倍）

## 3.3 对象的访问定位

- 建立对象是为了使用对象，程序通过栈上的 reference 数据来操作栈上的具体对象
- 由于 reference 类型在 Java 虚拟机规范中只规定了一个纸箱对象的引用，并没有定义这个引用该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式是取决于具体的虚拟机实现，目前主流的方式有使用句柄和直接指针两种
- 使用句柄访问的话，Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄则包含了对象实例数据与类型数据各自的具体地址信息（此时对象可以不在对象头维护类型的指针，直接通过句柄就可以找到），该方式有点像二重指针，引用指向句柄，句柄指向对象和类型
- 若使用直接指针访问，则 Java 堆对象的对象头中必须放置对应的对象类型信息，然后 reference 中存储的直接就是对象地址
- 这两种对象访问方式各有优势 : 
    - 使用句柄的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾回收时移动对象时非常普遍的行为）时只有改变句柄中的实例数据指针，而 reference 本身不需要修改
    - 使用直接指针访问方式的最大好处就是速度更快，其节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本
- 就本书主要讨论的 Sub HotSpot 虚拟机而言，他是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见

# 4. 实战：OutOfMemoryError 异常

- 在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemoryError(OOM) 的可能
- 本节通过若干实例来验证异常发生的场景，并且会逐步介绍几个与内存相关的最基本的虚拟机参数


## 4.1 Java 堆溢出

- 限制 Java 堆的大小为 20 MB，不可扩展（将堆的最小值 -Xms 参数与最大值 -Xmx 参数设置为一样即可避免堆自动扩展）
- 通过参数 -XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时 Dump 出当前的内存堆转储快照以便事后分析（第 4 章）
- 一般需要通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，终点是确定内存中的对象是否是必要的，也就是先分清楚是出现了内存泄漏还是内存溢出
- 打开堆转储快照文件后，如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链，于是就能找到泄漏对象通过什么路径与 GC Roots 相关联并导致垃圾回收器无法自动回收
- 掌握了泄漏对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置
- 如果不存在内存泄漏，即内存中的对象都是需要的，那说明是内存不足了，此时应该检查虚拟机的堆参数 (-Xmx 与 -Xms) 以及物理内存是否可以调大，从代码上检查是否某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗
- 下述代码使用死循环不断分配对象，从而导致堆溢出
```java
/**
 * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOM {

    static class OOMObject {

    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<OOMObject>();

        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

## 4.2 虚拟机栈和本地方法栈溢出

- 首先明确，虚拟机栈是线程私有的，即每个线程有自己的虚拟机栈（固定大小或者可以扩展），当当前线程由于栈帧过大以及递归深度过深导致所需内存大于栈的大小时，则会抛出 StackOverflowError 异常
- 由于在 HotSpot 虚拟机中不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoss 参数（设置本地方法栈大小）存在，但实际上无效，栈容量只能通过 -Xss 参数设定
- 关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常 :
    - 如果线程请求的栈深度（函数调用或递归深度）大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常
    - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则将抛出 OutOfMemoryError 异常（暂时不知如何测试）
- 但上述两种情况存在一种重叠的情况，当栈空间无法继续分配时，到底是内存太小还是已使用的栈空间太大，本质上是同一件事情的两种描述
- 经测试，递归深度和设置的栈容量大小有关 -Xss 设置的越大（应该是固定大小），则本地单线程的允许的栈深度越大，超出后则抛出 StackOverflowError 异常
- 例如，下述代码，使用 -Xss 设置栈容量为 128k，结果抛出 StackOverflowError 异常，若改变栈容量，可以看到输出的栈深度也会相应的改变
```java
/**
 * VM Args: -Xss128k
 */
public class JavaVMStackSOF {

    private short stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            throw e;
        }
    }
}
```
- 实验结果表明，在单个线程下，无论是由于栈帧太大还是由于虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常（对于自动扩展的情况不知道怎么测）
- 若测试时不限于单线程，通过不断建立线程的方式可以产生内存溢出异常，但这种情况的内存溢出并不是栈空间不够大而导致的，而是每个线程占用一定的栈空间，而线程太多，导致总的栈空间超出了物理内存，从而产生内存溢出，在这种情况下，每个线程的栈分配到的内存越大，反而越容易产生内存溢出的异常
- 操作系统分配给每个进程的内存都是有限制的，碧如 32 为的 Windows 限制为 2 GB，虚拟机还提供了参数来控制 Java 堆和方法区的这两部分内存的最大值，剩余可用内存即为 2 GB - Xmx(最大堆容量) - MaxPermSize(最大方法区容量)，程序计数器消耗内存很小，忽略不计，如果虚拟机进程本身消耗的内存不计算在内，则剩下的内存就由虚拟机栈和本地方法栈瓜分，每个线程分配到的栈容量越大，那么可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽
- 因此，对于并发很高的多线程环境下，不能把虚拟机栈设置过大，否则能新建的线程数量是很少的，过多的线程也会导致 OutOfMemoryError 异常
- 使用虚拟机默认参数，栈深度在大多数情况（每个方法的栈帧大小并不一样，因此只能说大多数）下达到 1000 - 2000 没有问题，对于正常的方法调用和递归，这个深度应该完全够用了
- 但是，如果由于多线程环境下，建立过多的线程导致内存溢出，在不能减少线程数（即并发量）或者更换 64 位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程，如果没有这方面经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到
- 下述代码设置单个线程的虚拟机栈大小为 2 M，每个线程运行一个死循环占用着这个虚拟机栈，然后开一个外层循环循环创建线程，直至内存溢出（注意执行下述代码前要先保存当前工作，由于 Windows 平台的虚拟机中，Java 的线程是映射到操作系统的内核线程上的，因此上述代码执行时有较大的风险，可能会导致操作系统假死）
```java
/**
 * VM Args: -Xss2M
 */
public class JavaVMStackOOM {

    private int i = 0;

    private void dontStop(int n) {
        while (true) {
            System.out.println(n);
        }
    }

    public void stackLeakByThread() {
        while (true) {
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    dontStop(i++);
                }
            });
            thread.start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM oom = new JavaVMStackOOM();
        oom.stackLeakByThread();
    }

}
```
- 但我测试虽然内存会占满，但不会抛出异常，不知道是 jvm 的优化还是 win10 的优化

## 4.3 方法区和运行时常量池溢出

- 由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起

**运行时常量池**

- 前面提到 JDK 1.7 开始逐步“去永久代”，再次就以测试代码观察该事对程序的实际影响
- `String.intern()` 是一个 Native 方法，其作用是 : 如果字符串常量池已经包含一个等于此 String 对象的字符串，则返回代表池中的这个字符串的 String 对象；否则将该 String 对象包含的字符串添加到常量池中，并返回此 String 对象的引用
- 在 JDK 1.6 以及之前的版本，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPerSize 限制方法区大小，从而间接限制其中的常量池容量
```java
/**
 * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {

    public static void main(String[] args) {
        // 使用 List 保持着常量池的引用，避免 Full FC 回收常量池行为
        List<String> list = new ArrayList<String>();

        // 10 MB 的 PermSize 在 integer 范围内足够产生 OOM 了
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
```
- 从运行结果 `java.lang.OutOfMemoryError: PermGen space` 可以看出，在 OutOfMemoryError 后面跟随的提示信息 `PermGen space` 说明是运行时常量池溢出，PermGen 表示 Permanent Generation，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分
- 而使用 JDK 1.7 执行上述代码会得到不同的结果，while 循环将一直执行下去，因为 JDK 1.7 的字符串常量池发生了一些变化
- 分别在 JDK 1.6 和 JDK 1.7 下运行下述代码 :
```java
public class RuntimeConstantPoolOOM {

    public static void main(String[] args) {
//        String a1 = "计算机软件"; // 让常量池已经有这个字符串，则会变 false
        String str1 = new StringBuilder("计算机").append("软件").toString();
        System.out.println(str1.intern() == str1);
        

        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2.intern() == str2);
    }
}
```
- 对于上述代码，JDK 1.6 会得到两个 false，而 JDK 1.7/1.8 会先后得到一个 true 和一个 false，产生差异的原因是 :
    - JDK 1.6 中，intern() 方法会吧首次遇到的字符串实例复制到永久代中，返回的就是永久代中的字符串实例的引用，而由 StringBuilder 创建的字符串实例是在 Java 堆上，所以必然不是同一个引用
    - JDK 1.7 （以及其他部分虚拟机，如 JRockit）中，intern() 实现不会在复制实例到方法区的常量池中，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和 StringBuilder 创建的那个字符串实例就是同一个，而对于 str2 返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，因此 String.intern() 返回的就是在常量池中的那个实例的引用，自然和堆中的不相等
- 值得一提的是，如果我们取消掉 a 的那行注释，则字符串 "计算机软件" 将预先存在于字符串常量池中，因此 String.intern 返回的就是常量池中的那个实例的引用，而 StringBuilder 返回的是在堆中的，自然不相同
- 还要注意，对于这样的代码，不管是在 1.6 还是 1.7 都会返回 true，因此字面值就是存储在字符串常量池中的 :
```java
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        String str = "你好";
        System.out.println(str.intern() == str);
    }
}
```

**方法区**

- 方法区用于存放 Class 的相关信息，如类型、访问修饰符、常量池、字段描述、方法描述等，对于这些区域的测试，基本思路是运行时产生大量的类取填满方法区，直到溢出
- 虽然直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstructorAccessor 和动态代理等），但在本次实验中操作起来比较麻烦，因此此处借助 CGLib 直接操作字节码运行时生成大量的动态类
- 值得特别注意的是 : 我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中，当前的很多主流框架，例如 Spring, Hibernate，在对类进行增强时，都会使用到 CGLib 这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class 可以载入内存
- 另外，JVM 上的动态语言（例如 Groovy 等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与下述代码相似的场景
```java
/**
 * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
 */
public class JavaMethodAreaOOM {

    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                    return methodProxy.invokeSuper(obj, args);
                }
            });
            enhancer.create();
        }
    }

    static class OOMObject {

    }
}
```
- 方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的，因此在经常动态生成大量 Class 的应用中，需要特别注意类的回收
- 这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）

## 4.4 本机直接内存溢出

- DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，若不指定，则默认与 Java 最大堆 (-Xmx 指定)一样
- 下述代码越过 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）
- 虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出的异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 `unsafe.allocateMemory()`
```java
/**
 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
 */
public class DirectMemoryOOM {

    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) throws Exception{
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }
}
```
- 由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果读者发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，可以考虑一下是不是这方面的原因

# 9. 补充内容

## 9.1 局部变量表

- [局部变量表](https://blog.csdn.net/tugele/article/details/78886522)
- [基本类型 Slot](https://hllvm-group.iteye.com/group/topic/38400)
- 我们已知，栈帧存储了方法的**局部变量表**、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程，现在重点讲解局部变量表
- 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**
- 在 Java 程序编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量，也就是说，局部变量表的大小在编译期就已经确定，在整个方法的运行期间大小不会修改（其实栈帧也是，局部变量表是栈帧的一部分，自然也是）

**Slot 标准**

- 局部变量表的容量以变量槽（Variable Slot，下称 Slot）为最小单位，虚拟机规范中并没有明确指明一个 Slot 应占用的内存空间大小，只是很有导向性地说到每个 Slot 都应该能存放一个 boolean、byte、char、short、int、float、reference、returnAddress 类型的数据
- 注：Java 虚拟机规范中没有明确规定 reference 类型的长度，它的长度与实际使用 32 还是 64 位虚拟机有关，如果是 64 位虚拟机，还与是否开启某些对象指针压缩的优化有关，而一个 Slot 必须能存下一个 reference，因此一个 Slot 的占用位数的设计和 reference 的设计以及 jvm 位数有关
- reference 类型表示对一个对象实例的引用，虚拟机规范既没有说明他的长度，也没有明确指出这种引用应有怎样的结构。但一般来说，虚拟机实现至少都应当能通过这个引用做到两点 : 
    - 一是从此引用中直接或间接地查找到对象在 Java 堆中的数据存放的起始地址索引，
    - 二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现 Java 语言规范中定义的语法约束约束。
- returnAddress 类型目前已经很少见了，它是为字节码指令 jsr、jsr_w 和 ret 服务的，指向了一条字节码指令的地址，很古老的 Java 虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替
- 对于 64 位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间。Java 语言中明确的（reference 类型则可能是 32 位也可能是 64 位）长度为 64 位的数据类型只有 long 和 double 两种

**Slot 实现方式**

- HotSpot VM有 32 位和 64 位版。另外在 JVM 栈的方面，解释器用的栈桢（interpreted frame）与被 JIT 编译后的代码用的栈桢（compiled frame）的布局也不一样。 
- 32 位版上，解释器的栈桢布局是以 32 位为单位的 slot 来存储局部变量与操作数栈项的。情况跟楼主的想像相同：1 个 char 在局部变量与在操作数栈上都占4字节，编译后代码的栈桢布局里，局部变量也是用 32 位 slot 来存储，没有操作数栈。 
- 64 位版上，解释器的栈桢的 slot 是 64 位的。这里 1 个 char 会占用 8 字节，1 个 boolean、short、int、float 也是 8 字节；而 1 个 long 或 double 仍然占 2 个slot，也就是 64*2＝128 字节。这主要是为了实现方便，代码容易与 32 位版统一起来。 
- 编译后代码的栈桢里，局部变量也是用 64 位 slot，但 long 和 double 可以只占 1 个 slot；同样没有操作数栈。这里 1 个 char 也占 8 字节。 
- 在 Java 堆上，HotSpot VM 采用紧凑的对象布局。字段会根据其宽度做重排序，以期尽量有效的使用内存。除了 boolean 占 1 字节外，其它数据类型的字段都占与其有效宽度相同的大小。数组也是一样。所以在 HotSpot VM 里 Java 对象的 char 类型字段以及 char[] 里的 char 都是占 2 字节。 

**Slot 使用**

- 虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始至局部变量表最大的 Slot 数量。如果访问的是 32 位数据类型的变量，索引 n 就代表了使用第 n 个 Slot，如果是 64 位数据类型的变量，则说明会同时使用 n 和 n+1 两个 Slot。对于两个相邻的共同存放一个 64 位数据的两个 Slot，不允许采用任何方式单独访问其中的某一个，Java 虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常
- 在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 的方法），那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字 “this” 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot（注意方法内部的变量也会占用 Slot）
- 为了尽可能节省栈帧空间，局部变量中的 Slot 是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码 PC 计数器的值已经超出了某个变量的作用域，那这个变量对应的 Slot 就可以交给其他变量使用。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，对于下属代码，虽然 placeholder 作用域已经结束，但由于 slot 复用导致不会触发 gc 回收 :
```java
// VM Args: -verbose:gc
public static void main(String[] args) {
    {
        byte[] placeholder = new byte[64 * 1024 * 1024];
    }
    // int a = 0; // 取消掉这一行就会触发 gc 回收
    System.gc();
}
```
- 在上述代码中，虽然已经离开了 placeholder 的作用域，但在此之后，没有任何局部变量表的读写操作，placeholder 原本占用的 Slot 还没有被其他变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微，因为一个方法往往不会执行很长的时间，当方法结束时相关 Slot 回收，会进一步导致 placeholder 回收
- 但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量的内存、实际上已经不会再使用的变量，手动将其设置为 null 值（用来代替那句 int a=0，把变量对应的局部变量表 Slot 清空）便不见得是一个绝对无意义的操作，因为提前设置为 null 就有可能提前进行回收，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到 JIT 的编译条件）下的 “奇技” 来使用。Java 语言的一本著名书籍《Practical Java》中把 “不使用的对象应手动赋值为 null” 作为一条推荐的编码规则