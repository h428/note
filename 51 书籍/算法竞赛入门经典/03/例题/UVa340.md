
# 1. 题目大意

- 给定答案序列和用户猜测序列，统计有多少数字位置正确（记为 A），统计都多少数字在两个序列中都出现过但位置不对（记为 B）
- 每组输入以 n 开头，表示序列长度，然后跟着一行答案序列以及若干行猜测序列
- 当猜测序列全为 0（或者第一个为 0）时表示该组序列结束

# 2. 解题思路

- 对于位置正确的数的统计，即对两个序列注意比对即可
- 对于在两个序列中都出现过但位置不对的统计，可转化为对于 1-9 的数字 d，分别统计 d 在两个序列中分别出现的次数，然后将最小值（即包括了正确和错位的数）累加到总和 B 中，并在最终总和减去正确位置的数 A 即可

# 3. 题解

```C++
/* UVa 340 Master-Mind Hints  */
#include <cstdio>

const int maxn = 1010;


int main() {
#ifdef _LOCAL
    freopen("E:\\in.txt", "r", stdin);
#endif

    int n, a[maxn], b[maxn];
    int kase = 0;

    while (scanf("%d", &n) == 1 && n) { // n = 0 时输入结束
        printf("Game %d:\n", ++kase);
        for (int i = 0; i < n; ++i) {
            scanf("%d", a+i);
        }
        while (true) {
            int A = 0, B = 0;
            for (int i = 0; i < n; ++i) {
                scanf("%d", b+i);
                if (a[i] == b[i]) {
                    ++A; // 统计位置正确的数
                }
            }
            if (b[0] == 0) {
                break; // 正常猜测序列不会有 0， 所以只判断第一个数是否为 0 即可，是则本组输入结束
            }
            for (int d = 0; d <= 9; ++d) {
                int c1 = 0, c2 = 0; // 统计数字 d 在答案序列和猜测序列中各出现多少次
                for (int i = 0; i < n; ++i) {
                    if (a[i] == d) {
                        ++c1; // 答案序列中 d 的个数
                    }
                    if (b[i] == d) {
                        ++c2; // 猜测序列中 d 的个数
                    }
                }
                // 最小值即为同时在两个序列中出现的个数（包括了位置正确的），将最小值累加到 B 中
                if (c1 < c2) {
                    B += c1;
                } else {
                    B += c2;
                }
            }
            printf("    (%d,%d)\n", A, B-A); // 最终输出时，要减去正确猜测的才是错位个数
        }

    }

    return 0;
}
```